
<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="icon" sizes="16x16" href="images/icon16.ico?a"> <!-- compatibility -->
<link rel="shortcut icon" sizes="16x16" href="images/icon16.png?a"> <!-- firefox -->
<link rel="icon" sizes="32x32" href="images/icon32.png?a"> <!-- chrome -->
<link rel="icon" sizes="192x192" href="images/iconbig.png?a"> <!-- large -->
<link rel="apple-touch-icon" href="images/iconbig.png?a"> <!-- large 2 -->
<link rel="image_src" href="images/iconbig.png?a"> <!-- large 3 -->
<!--<meta property="og:site_name" content="12-SBS2">
<meta property="og:description" content="SmileBASIC Source 2">
<meta name="og:image" content="images/iconbig.png?a">
<meta name="theme-color" content="#009688">-->

<style>
@font-face{
	font-family:roboto;
	font-weight:400;
	font-style:normal;
	src:url(fonts/roboto-400.woff2) format('woff2'),url(fonts/roboto-400.woff) format('woff')
}
@font-face{
	font-family:roboto;
	font-weight:400;
	font-style:italic;
	src:url(fonts/roboto-400i.woff2) format('woff2'),url(fonts/roboto-400i.woff) format('woff')
}
@font-face{
	font-family:roboto;
	font-weight:700;
	font-style:normal;
	src:url(fonts/roboto-700.woff2) format('woff2'),url(fonts/roboto-700.woff) format('woff')
}
@font-face{
	font-family:roboto;
	font-weight:700;
	font-style:italic;
	src:url(fonts/roboto-700i.woff2) format('woff2'),url(fonts/roboto-700i.woff) format('woff')
}

/*@font-face{font-family:roboto mono;font-weight:400;font-style:normal;src:url(/fonts/roboto_mono/400.woff2) format('woff2'),url(/fonts/roboto_mono/400.woff) format('woff')}
@font-face{font-family:roboto mono;font-weight:400;font-style:italic;src:url(/fonts/roboto_mono/400i.woff2) format('woff2'),url(/fonts/roboto_mono/400i.woff) format('woff')}
@font-face{font-family:roboto mono;font-weight:700;font-style:normal;src:url(/fonts/roboto_mono/700.woff2) format('woff2'),url(/fonts/roboto_mono/700.woff) format('woff')}
@font-face{font-family:roboto mono;font-weight:700;font-style:italic;src:url(/fonts/roboto_mono/700i.woff2) format('woff2'),url(/fonts/roboto_mono/700i.woff) format('woff')}*/
body.pageMode main {
	height: 90vh;
	display: block;
}

* {
	margin: 0;
	box-sizing: border-box;
	-webkit-box-sizing: border-box;
	overflow-wrap: break-word;
}
/* may need more things here */
.textItem, .item, .buttonContainer button {
	vertical-align: top;
}

/* html.loading * {
	cursor: progress !important;
}*/

html {
	background-color: red;
	font-family: roboto, fontello, sans-serif;
}

/* all elements with user content, where whitespace should be preserved */
.pre {
	white-space: pre-wrap;
	unicode-bidi: embed;
}

a {
	
}

/*a:visited {
	color: #00A;
	color: inherit;
}*/
/* heck all this blue text */

.time {
	color: #333;
	font-size: 0.9em;
	vertical-align: baseline;
}

.avatar {
	border: 1px solid white;
}

a {
	text-decoration: none;
}

a:hover {
	color: #06F;
}

textarea {
	border-radius: 2px;
	border: 2px solid #00C8B4;
	box-shadow: 0.1rem 0.2rem 0.3rem -0.2rem rgba(13,13,13,0.5);
	max-width: 100%;
	font-family: roboto, sans-serif;
	font-size: 0.8em;
}

sup {vertical-align: super;}

sub {vertical-align: sub;}

.spacer {
	-webkit-flex-grow: 1;
	flex-grow: 1;
}

.rightAlign {
	float: right;
}

/* These 3 classes handle like 90% of the layout lol */
.bar { /* contains textitems and items */
	display: block;
	overflow: hidden;
	box-sizing: content-box;
	-webkit-box-sizing: content-box;
	/*padding: 0 0.5rem !important;*/
	/* set min-height */
}
/*.bar > img:first-child, .bar > .iconBg:first-child {
	margin-left: -0.5rem !important;
}
.bar > img:last-child, .bar > .iconBg:last-child {
	margin-right: -0.5rem !important;
}*/

.textItem { /* basically anything within a .bar */
	max-width: 100%;
	display: inline;
	/* set min-height, line-height */
}
.item { /* for images and other blocks that can't wrap */
	display: inline-block;
	max-width: 100%;
	/* set height */
}

@keyframes colorPulse{ 0% {background-color: #a1cfef} 100% {background-color: #a0f4df}}


/****************************
 ** Main Container Element **
 ****************************/
body {
	display: -webkit-flex;
	display: flex;
	-webkit-flex-direction: column;
	flex-direction: column;
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	background-color: white;
}

/* most elements will be fixed-height, and should never shrink */
body > * {
	-webkit-flex-shrink: 0;
	flex-shrink: 0;
}

/* visibility control */
body:not(.pageMode) .pageMode,
body:not(.pageMode) .pageChatMode,
body:not(.editorMode) .editorMode,
body:not(.categoryMode) .categoryMode,
body:not(.navMode) .navMode,
body:not(.userMode) .userMode,
body:not(.membersMode) .membersMode,
body:not(.registerMode) .registerMode,
body:not(.settingsMode) .settingsMode,
body:not(.activityMode) .activityMode,
body:not(.cateditMode) .cateditMode,
body:not(.userMode):not(.pageMode) .pageUserMode,
body:not(.homeMode) .homeMode,
body:not(.testMode) .testMode,
body:not(.fileMode) .fileMode {
	display: none;
}

/*************
 ** Top Bar **
 *************/
.navPane {
	min-height: 1.5rem;
	background-color: #333;
	-webkit-transition: background-color 0.1s ease;
	transition: background-color 0.1s ease;
}

.navPane a {
	color: #BCF;
}

.navPane a:hover {
	color: #9AF;
}

html.f-loading .navPane {
	background-color: rgb(0,150,136);
}

html.f-error .navPane {
	background-color: #800;
}

html:not(.f-loggedIn) .loggedIn,
html.f-loggedIn .loggedOut {
	display: none;
}

.navPane .item {
	height: 1.5rem;
}

.navPane .textItem{
	min-height: 1.5rem;
	line-height: 1.5rem;
}

.myAvatar {
	width: 1.5rem;
}

.myName {
	color: white;
	margin: 0 0.5rem;
}

.path {
	font-weight: bold;
	color: white;
}

.pathSeparator {
	padding: 0 0.2rem;
}

/****************
 ** Title Pane **
 ****************/
.titlePane {
	background-color: #DDD;
	padding: 0 0.1rem;
	border-bottom: 2px solid black;
}

.titlePane .iconBg {
	width: 2rem;
}

.titlePane .userLink img {
	margin: 0 0.7ch;
}

.editingLabel {
	padding-left: 0.3rem;
	font-weight: bold;
}
.pageTitle {
	font-weight: bold;
	padding-right: 0.5rem;
	font-size: 1.6rem;
}

html:not(.f-canEdit) .canEdit {
	display: none;
}

.errorMode .titlePane {
	background-color: pink;
	color: maroon;
	font-family: monospace;
}

/*******************************
 ** content+sidebar container **
 *******************************/
.sideBarContainer {
	display: flex;
	display: -webkit-flex;
	-webkit-flex-direction: row;
	flex-direction: row;
	-webkit-flex-grow: 1;
	flex-grow: 1;
	-webkit-flex-shrink: 1;
	flex-shrink: 1;
	overflow-x: hidden;
}

.m {
	width:100%;

	-webkit-flex-grow: 0;
	flex-grow: 0;
	display: -webkit-flex;
	display: flex;
	-webkit-flex-direction: column;
	flex-direction: column;
}

.sideBar {
	-webkit-flex: 1 0 0;
	flex: 1 0 0;
	background-color: rgba(204, 221, 238, 0.9);
	border-left: 2px solid black;
	/*-webkit-transition: margin-left 0.25s ease, transform 0.25s ease;
	transition: margin-left 0.25s ease, transform 0.25s ease;*/
	overflow: auto;
}

html:not(.f-sidebar) .sideBar {
	-webkit-transform: translateX(100%);
	transform: translateX(100%);
}

html:not(.f-sidebar) .m {
	width: 100% !important;
}

html.f-sidebar .m {
	resize: horizontal;
	width: 70vw;
	overflow:auto;
}

/**********
 ** main **
 **********/
main {
	display: -webkit-flex;
	display: flex;
	-webkit-flex-direction: column;
	flex-direction: column;
	overflow-y: auto;
	flex-basis: 0;

	-webkit-flex-grow: 1;
	flex-grow: 1;
	-webkit-flex-shrink: 1;
	flex-shrink: 1;

	min-height: 100px;
	/*padding: 0.5rem;*/
	/*overflow-y: scroll;*/
	
	/*min-height: 300px;
	height: 300px;*/
}

/*******************
 ** Category Pane **
 *******************/
.categoryPage {
	font-weight: bold;
	background-color: #EEE;
	padding-left: 0.4rem;
}
.categoryPage, .categoryDescription, .member {
	border-bottom: 1px solid gray;
}
.categoryPage .username {
	padding: 0 0.4rem;
}

.rem1-7 {
	min-height: 1.7rem;
}
.rem1-7 .item {
	height: 1.7rem;
	line-height: 1.7rem;
}
.rem1-7 .textItem {
	min-height: 1.7rem;
	line-height: 1.7rem;
}
.rem1-7 .avatar {
	width: 1.7rem;
}
.rem1-7 .iconBg {
	width: 1rem;
	margin-right: 0.2rem;
}
.rem2-3 {
	min-height: 2.3rem;
}
.rem2-3 .item {
	height: 2.3rem;
	line-height: 2.3rem;
}
.rem2-3 .textItem {
	min-height: 2.3rem;
	line-height: 2.3rem;
}
.rem2-3 .avatar {
	width: 2.3rem;
}
.rem2-3 .iconBg {
	width: 1.5rem;
}

.px40 {
}
.px40 .item {
	height: 40px;
	line-height: 40px;
}
.px40 .textItem {
	min-height: 40px;
	line-height: 40px;
}

/***************
 ** Page Pane **
 ***************/

/*******************
 ** Chat Userlist **
 *******************/
.userlist {
	background-color: #EEE;
	border-bottom: 1px solid gray;
}

/***********************
 ** Chat Message Pane **
 ***********************/
/* ... */
.messageList {
	padding-bottom: 0.7rem;
}

.spacer {
	border-bottom: 1px solid gray;
}

/** Chat Messages **/
.message {
	font-size: 0.9rem;
	padding: 0.4rem 0.5rem;
	white-space: pre-wrap;
	border-left-width: 0.5em;
	border-left-style: solid;
	border-left-color: rgb(255,153,153);
	clear: both;
	overflow: auto;
}
.systemMessage {
	background-color: rgba(187,187,187, 0.2);
	font-weight: bold;
	color: #666;
	border-left: 0.5em solid rgb(187,187,187);
}
.ownMessage {
	background-color: rgba(255,153,153, 0.2);
}
.messageTime {
	float: right;
	font-weight: normal;
	padding-right: .5em;
	color: #666;
}
.message .avatar {
	display: inline-block;
	width: 3.5rem;
	height: 3.5rem;
	border: 1px solid #777;
	margin-right: 0.5rem;
	float: left;
}
.message .username {
	margin-left: 4rem;
	display: block;
	/*white-space: pre;
	overflow: hidden;
	text-overflow: ellipsis;*/
}
.messageUsername {
	display: inline-block;
}
.messageContents {
	display: block;
	vertical-align: top;
	overflow: auto;
}
.messagePart.markup-root {
	margin: .2rem;
}
.messagePart img {
	max-width: 100%;
	max-height: 10vh;
	border: 1px solid silver;
}
/****************
 ** Chat Input **
 ****************/
.inputPane {
	height: 3.25rem;
	display: -webkit-flex;
	display: flex;
	-webkit-flex-direction: row;
	flex-direction: row;
}
.inputPane > * {
	height: 100%;
}
.inputPane > textarea {
	-webkit-flex-grow: 1;
	flex-grow: 1;
	resize: none;
	min-width: 0;
}

.inputPane > button {
	width: 3.25rem;
}

/**********************
 ** Editor Info Pane **
 **********************/

/*****************
 ** Editor Pane **
 *****************/
.editorPane {
	display: -webkit-flex;
	display: flex;
	-webkit-flex-direction: column;
	flex-direction: column;
	-webkit-flex-grow: 1;
	flex-grow: 1;
}

.editorPreview {
	-webkit-flex-grow: 1;
	flex-grow: 1;
	-webkit-flex-shrink: 1;
	flex-shrink: 1;
	overflow-y: auto;
	-webkit-flex-basis: 0;
	flex-basis: 0;
	min-height: 4rem;
}

.editorTextarea > textarea {
	resize: vertical;
	width: 100%;
	height: 40vh;
	min-height: 5rem;
	box-sizing: border-box;
}

/***************
 ** User Page **
 ***************/
.member {
	display: block;
	background-color: #EEE;
}

.memberName {
	padding: 0 0.5rem;
}

/* do we even need this */
.bottomSpacer {
	-webkit-flex-shrink: 0;
	flex-shrink: 0;
	height: 1.5rem;
}

.listItem {
	background-color: #EEE;
	border-bottom: 1px solid gray;
	padding: 0 0.2rem;
}

.activityMode > .listItem > *:first-child {
	margin-left: -0.2rem;
}

.listItem a {
	font-weight: bold;
}

.userPageBox {
	align-items: flex-start;
	display: -webkit-flex;
	display: flex;
	-webkit-flex-direction: row;
	flex-direction: row;
	max-height: 40vh;
	overflow: auto;
	border-bottom: 1px solid gray;
	/* todo: make this outside of scroller and have activity list scroll separately*/
}

.userPageBox .userPageAvatar {
	width: 10rem;
	height: 10rem;
	display: inline-block;
	-webkit-flex-shrink: 1;
	flex-shrink: 1;
}

.userPageBox .pageContents {
	/*width: 10rem;*/
	flex-basis: 0;
}

.nav {
	-webkit-flex-shrink: 0;
	flex-shrink: 0;
	border-bottom: 1px solid gray;
	background-color: #333;
}

.nav > span {
	color: white;
}

.loginField {
	width: 5rem;
}

button {
	line-height: normal !important;
	font-size: 0.8em;
	cursor: pointer;
}
input {
	font-size: 0.8em;
}

table.form td:first-child {
	text-align:right;
}
table.form td {
	padding: 0;
}
table.form th {
	padding: 0;
	text-align:right;
}

img.item {
	vertical-align: top;
}

.userPageContents {
	
	-webkit-flex-grow: 1;
	flex-grow: 1;
}

.voteButton[data-selected] {
	background-color: lime;
}

/* hecko yo */
.pageContents {
	max-width:100%;
	overflow-x:auto;
	-webkit-flex-shrink: 0;
	flex-shrink: 0;
}

.listItem .avatar {
	margin-right: 0.3ch;
}

.username {
	font-weight: bold;
	unicode-bidi: embed;
	white-space: pre-wrap;
}

.member .avatar {
	margin-right: 0.7ch;
}

html:not(.f-myUserPage) .myUserPage {
	display: none;
}

@media (max-width: 700px) {
	.userPageBox {
		flex-direction: column;
		max-height: none;
	}
	.userPageBox .userPageContents {
		width: 100%;
		flex-basis: auto;
	}
}

/* narrow screen: fullscreen sidebar */
@media (max-width: 700px) {
	.sideBar {
		width: 100%;
		height: 100%;
		position: fixed;
		bottom: 0;
		right: 0;
		left: 0;
		border-left: none;
		transform: none;
		-webkit-transition: -webkit-transform 0.2s ease;
		-webkit-transition: transform 0.2s ease;
		transition: -webkit-transform 0.2s ease;
		transition: transform 0.2s ease;
	}
	html:not(.f-sidebar) .sideBar {
		margin-left: 0;
		-webkit-transform: translateX(0);
		transform: translateX(0);
	}
	html:not(.f-mobileSidebar) .sideBar {
		-webkit-transform: translateX(100%);
		transform: translateX(100%);
	}
	.m {
		width: 100% !important;
	}
}

/* for devices with small screens */
@media (max-width: 700px), (max-height: 500px) {
	/* make the entire page scroll */
	/* todo: make chat mode work better here */
	body:not(.pageMode) {
		position: static;
		min-height: 100vh;
		font-size: 0.9em;
	}
	textarea {
		font-size: 1em; /* prevent zoom in on iphone */
	}
	body:not(.pageMode) main {
		height: auto !important;
		-webkit-flex-basis: auto;
		flex-basis: auto;
	}
	html {
		background-color: transparent;
	}
	.editorPreview {
		-webkit-flex-basis: auto;
		flex-basis: auto;
	}
	.userPageBox {
		max-height: none;
	}
	.inputPane textArea {
		font-size: 1rem;
	}
}

.pageInfoPane {
	background-color: #EEE;
	overflow: auto;
	flex-shrink: 0;
}

.pageMetaIcon {
	width: 40px;
	height: 40px;
}

.html:not(.f-hasKey) .hasKey {
	display: none;
}

.metaKey.brokenKey .metaKey.invalidKey {
	text-decoration: line-through;
}

.metaKey {
	font-family: consolas;
	font-weight: bold;
	font-size: 1.3rem;
	margin: 0 0.5rem;
}

.metaTitle {
	font-family: consolas;
	margin: 0 0.3rem;
}

.gallery {
	width: 20rem;
	height: 10rem;
	display: inline-block;
	float: left;
}

.gallery img {
	max-height: 100%;
	max-width: 16rem;
}

.gallery button {
	height: 100%;
	width: 2rem;
}

.metaInfo {
	display: inline;
}

.categoryNav {
	border-bottom: 1px solid gray;
}

.memberNav {
	border-bottom: 1px solid gray;
}

.buttonContainer {
	padding: 1px;
	display: inline-block;
}

.buttonContainer button {
	margin: 0;
	padding: 0 0.5rem;
	background-color: #EEE;
	border: 2px solid gray;
	height: 100%;
	overflow-y: hidden;
	border-style: outset;
	border-radius: 2px;
}

.buttonContainer > a {
	width: 100%;
	height: 100%;
	display: inline-block;
}

.buttonContainer button:hover {
	border-color: #59E;
}

.buttonContainer button:active {
	border-style: inset;
}

.ib {
	display: inline-block;
}

.iconBg {
	background-repeat: no-repeat;
	background-size: contain;
	background-position: center;
	margin-right: 0.3rem;
}

.iconBg-page {
	background-image: url("icons/page.png");
}
.iconBg-pin {
	background-image: url("icons/pin.png");
}
.iconBg-category {
	background-image: url("icons/folder.png");
}
.iconBg-hiddenpage {
	background-image: url("icons/hiddenpage.png");
}

.pageName {
	font-weight: bold;
}

.noColor {
	color: black;
}

body.pageMode .bottomSpacer {
	display: none;
}
body.fileMode .bottomSpacer {
	display: none;
}

.messagePart[data-linked] {
	background-color: rgba(255,255,0,0.3);
}

.messageGap {
	border: 1px dashed gray;
	margin: 0.3rem 0;
}

.fileThumbnail {
	display: inline-block;
	width: 52px;
	height: 52px;
	cursor: pointer;
}

.fileThumbnail > img {
	max-width: 50px;
	max-height: 50px;
	border: 1px solid black;
	-webkit-box-sizing: content-box;
	box-sizing: content-box;
}

.fileView {
	max-width: 100%;
	max-height: 100%;
}

.fileViewPane {
	flex-grow: 1;
	overflow: auto;
	flex-basis: 0;
}

html:not(.f-fileSelected) .fileSelected {
	display: none;
}

html:not(.f-fileUploading) .fileUploading {
	display: none;
}

.fileBox {
	border-bottom: 1px solid gray;
}

.closeSidebar {
	width: 100%;
}

.closeSidebar button {
	width: 100%;
}

html:not(.f-page) .pageItem {
	display: none;
}

.userPageBox .pageContents {
	max-height: 100%;
}

header :first-child {
	min-width: 0.3rem;
	display: inline-block;
}

.sideBar {
	display: flex;
	flex-direction: column;
}

.sidebarScroller {
	flex-grow: 1;
	overflow-y: scroll;
	flex-basis: 0;
	border-top: 1px solid gray;
}

.sidebarScroller .bar {
	display: block;
	/*padding: 0.2rem; mmm*/
	padding: 0 0.2rem;
	border-bottom: 1px solid gray;
}

.sidebarScroller .bar > :first-child {
	margin-left: -0.2rem;
}

.sidebarScroller .bar > :last-child {
	margin-right: -0.2rem;
}
.markup-root {
	white-space: pre-wrap;
	overflow-x: auto;
	/*display: table;*/
	vertical-align: baseline;
}

.markup-root table, .markup-root td, .markup-root th {
	border: 1px solid black;
	border-collapse: collapse;
}

.markup-root td, .markup-root th {
	padding: 0.2rem 0.3rem;
}

.markup-root table {
	margin: 0.25rem 0;
}

/*.markup-root * {
	vertical-align: baseline;
}*/

.markup-root h2, .markup-root h3 {
	border-bottom: 1px solid #eaecef;
	margin-bottom: 0.2rem;
	/*display: inline;*/
}

.markup-root h4 {
	/*display: inline;*/
}

.markup-root > :first-child {
	margin-top: 0;
}

.markup-root h2 {
	margin-top: 0.5rem;
}

.markup-root h3 {
	margin-top: 0.3rem;
}

.markup-root pre {
	font-size: 0.9em;
	font-family: consolas, monospace;
	color: white;
	background-color: black;
	white-space: pre-wrap;
	word-break: break-all;
}

.markup-root code {
	font-size: 0.9em;
	font-family: consolas, monospace;
	background-color: rgba(0,0,0,0.1);
	padding: 0 0.2rem;
}

.markup-root pre, .markup-root table {
	box-shadow: 2px 2px 2px #888888;
}

.markup-root pre {
	border: 1px solid black;
	padding: 0.5rem;
	margin: 0.25rem 0;
}

.markup-root {
	margin: 0.5rem;
}

.markup-root img {
	max-width: 100%;
	max-height: 10vh;
	display: block;
	-webkit-transition: all 0.25s ease;
	transition: all 0.25s ease;
	/*margin: 0 1px; why is this here */
}

.markup-root img:focus {
	max-height: 75vh;
}

.markup-root ol {
	margin-left: 2em;
	padding-left: 0;
}

.markup-root ul, .markup-root ol ol, .markup-root ul ol {
	margin-left: 1.1em;
	padding-left: 0;
}

.markup-root audio, .markup-root video, .markup-root .youtube {
	display: block;
	max-width: 100%;
}

.markup-root .youtube {
	width: 320px;
	max-height: none;
}

.markup-root .cell {
	background-color: white;
}

.markup-root .cell[data-bgcolor="red"] {
	background-color: #FCC;
}

.markup-root .cell[data-bgcolor="green"] {
	background-color: #CFC;
}

.markup-root .cell[data-bgcolor="yellow"] {
	background-color: #FFC;
}

.markup-root .cell[data-bgcolor="orange"] {
	background-color: #FEC;
}

.markup-root .cell[data-bgcolor="blue"] {
	background-color: #DEF;
}

.markup-root .cell[data-bgcolor="gray"] {
	background-color: #DDD;
}

.markup-root .spoilerButton {
	padding: 0 0.3rem;
	background-color: #EEE;
	border: 2px solid gray;
	border-style: outset;
	border-radius: 2px;
	margin-left: 0.2rem;
	margin-right: 0.2rem;
	margin-top: 1px;
	display: table;
}

.markup-root .spoilerButton:hover {
	border-color: #59E;
}

.markup-root spoilerButton:active {
	border-style: inset;
}

.markup-root .spoiler {
	padding: 0.5rem;
	border: 1px solid gray;
	background-color: #F8F8F8;
	margin-bottom: 1px;
}

.spoilerButton:not([data-show]) + .spoiler {
	display: none;
}

.markup-root .spoilerButton:not([data-show]):before {
	content: "Show ";
}

.spoilerButton[data-show] {
	border-bottom: none;
}

.markup-root .spoilerButton[data-show]:before {
	content: "Hide ";
}

.markup-root .invalid {
	background-color: pink;
}

.markup-root .error {
	background-color: #F55;
	border: 1px solid black;
	padding: 0.2rem;
	border-radius: 5px;
}

.markup-root .tableContainer {
	overflow-x: auto;
	max-width: 100%;
}

/*.markup-root th.cell {
	background-color: #222;
	color: white;
	border-color: white;
}*/

.markup-root blockquote {
	padding: 0.5rem;
	padding-left: 1.5rem;
	border: 1px solid gray;
	background-color: #eee;
	margin: 1px 0;
}

.markup-root blockquote > cite {
	margin-left: -1rem;
}

/*.markup-root blockquote[cite]::before {
	content: attr(cite) ":\A";
	white-space: pre;
	font-weight: bold;
	margin-left: -1rem;
	display: block;
	margin-bottom: 0.2em;
}*/
.markup-root pre {
	background-color: #000;
	color: #EEE;
}
.markup-root pre * {
	background-color: transparent;
}
.markup-root pre .name {
	color: #7FF5EF;
}
.markup-root pre .string {
	color: #59EE79;
}
.markup-root pre .number {
	color: #f359ab;
}
.markup-root pre .keyword {
	font-weight: bold;
	color: #2494f0;
}
.markup-root pre .comment {
	color: #a1f198;
}
.markup-root pre .variable {
	color: #fbf4cb;
}
.markup-root pre .function {
	color: #8d7ff5;
}
.markup-root pre .statement {
	color: #7ff5ef;
}
.markup-root pre .backslash {
	color: #777;
}
.markup-root pre .operator {
	color: #EEE;
}
.markup-root pre .equals {
	color: #EEE;
}

.markup-root pre .label {
	color: #f4963e;
}

.markup-root pre .word-operator {
	color: #2494f0;
}
.markup-root pre .to-step {
	color: #2494f0;
}
.markup-root pre .constant {
	color: #aeb5c2;
}


/*--highlight-question: #2494f0;*/

</style>
<script>
function hide(element) {
	element.style.display = 'none';
}

function show(element) {
	element.style.display = '';
}

function visible(element, state) {
	element.style.display = state ? '' : 'none';
}

function setChild(element, child) {
	element.innerHTML = "";
	if (child)
		element.appendChild(child);
}

function protocol() {
	if (window.location.protocol == "http:")
		return "http:";
	return "https:";
}

function parseJSON(json) {
	if (!json)
		return undefined;
	try {
		return JSON.parse(json);
	} catch (e) {
		return null;
	}
}

var flags = {};
function flag(flag, state) {
	if (!flags[flag] != !state) {
		if (state)
			flags[flag] = true;
		else
			delete flags[flag];
		var cls = "";
		for (flag in flags) {
			cls += " f-"+flag;
		}
		document.documentElement.className = cls;
	}
}

function forDict(dict, func) {
	for (key in dict)
		func(dict[key], key, dict);
}

function hasPerm(perms, id, perm) {
	return perms && perms[id] && perms[id].indexOf(perm) != -1
}

Object.assign = function(a, b) {
	for (key in b) {
		a[key] = b[key]
	}
	return a;
}
// Source: https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Local_storage

if (!window.localStorage) {
	window.localStorage = {
		getItem: function (sKey) {
			if (!sKey || !this.hasOwnProperty(sKey)) { return null; }
			return unescape(document.cookie.replace(new RegExp("(?:^|.*;\\s*)" + escape(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*"), "$1"));
		},
		key: function (nKeyId) {
			return unescape(document.cookie.replace(/\s*\=(?:.(?!;))*$/, "").split(/\s*\=(?:[^;](?!;))*[^;]?;\s*/)[nKeyId]);
		},
		setItem: function (sKey, sValue) {
			if(!sKey) { return; }
			document.cookie = escape(sKey) + "=" + escape(sValue) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/";
			this.length = document.cookie.match(/\=/g).length;
		},
		length: 0,
		removeItem: function (sKey) {
			if (!sKey || !this.hasOwnProperty(sKey)) { return; }
			document.cookie = escape(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
			this.length--;
		},
		hasOwnProperty: function (sKey) {
			return (new RegExp("(?:^|;\\s*)" + escape(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
		}
	};
	window.localStorage.length = (document.cookie.match(/\=/g) || window.localStorage).length;
}
// ok so
// logging in/out
// the big important things are
// - content permissions (when logged in, you can view hidden content, and edit/delete permissions apply)
// - long polling (must be logged in)
// so, when logging in, need to re-request permissions

// long poller plans:
// when viewing a page, you temporarily join that room
// you can then add that room to your list of currrent rooms in the sidebar (or just watch it, for notifications only)
//
// need to handle logging in/out though
// on login (or page load + logged in already),
// start long poller,
// on log out, stop long poller
// but keep list of joined rooms uh, somewhere I guess.
// user variable I suppose

function sbs2Request(url, method, callback, data, auth, cancel) {
	var x = new XMLHttpRequest();
	if (cancel)
		cancel[0] = function() {x.abort();console.log("aborted")};
	x.open(method, url);

	var start = Date.now();
	x.onload = function() {
		var code = x.status;
		var type = x.getResponseHeader('Content-Type');
		if (/^application\/json(?!=\w)/.test(type)) {
			try {
				var resp = JSON.parse(x.responseText);
			} catch(e) {
				resp = null;
			}
		} else {
			resp = x.responseText;
		}
		if (code==200) {
			callback(null, resp);
		} else if (code==408 || code==204 || code==524) {
			// record says server uses 408, testing showed only 204
			// basically this is treated as an error condition,
			// except during long polling, where it's a normal occurance
			callback('timeout', resp);
		} else if (code == 429) { // rate limit
			window.setTimeout(function() {
				callback('rate', resp);
			}, 100);
		} else if (code==401) {
			console.log(x);
			callback('auth', resp);
		} else if (code==404) {
			console.log("got 404");
			callback('404', resp);
		} else {
			alert("Request failed! "+code+" "+url);
			//console.log("sbs2Request: request failed! "+code);
			//console.log(x.responseText);
			console.log("REQUEST FAILED", x);
			try {
				resp = JSON.parse(resp);
			} catch(e) {
			}
			callback('error', resp, code);
		}
	}
	x.onerror = function() {
		var time = Date.now()-start;
		console.log("xhr onerror after ms:"+time);
		if (time > 18*1000) {
			console.log("detected 3DS timeout");
			callback('timeout');
		} else {
			alert("Request failed! "+url);
			console.log("xhr onerror");
			callback('fail');
		}
	}
	//x.setRequestHeader('Cache-Control', "no-cache, no-store, must-revalidate");
	x.setRequestHeader('Pragma', "no-cache"); // for internet explorer
	if (auth)
		x.setRequestHeader('Authorization', "Bearer "+auth);
	
	if (data) {
		if (data && data.constructor == Object) { //plain object
			x.setRequestHeader('Content-Type',"application/json;charset=UTF-8");
			x.send(JSON.stringify(data));
		} else { //string, formdata, arraybuffer, etc.
			x.send(data);
		}
	} else {
		x.send();
	}
	return x;
}

function queryString(obj) {
	if (!obj)
		return "";
	var items = [];
	for (var key in obj) {
		var val = obj[key];
		if (typeof val != 'undefined'){
			var item = encodeURIComponent(key)+"=";
			// array items are encoded as
			// ids:[1,2,3] -> ids=1&ids=2&ids=3
			
			if (val instanceof Array) {
				for(var i=0;i<val.length;i++){
					items.push(item+encodeURIComponent(val[i]));
				}
			// otherwise, key=value
			} else {
				items.push(item+encodeURIComponent(val));
			}
		}
	}
	
	if (items.length)
		return "?"+items.join("&");
	else
		return "";
}

function Myself(isDev) {
	this.userCache={};
	this.userRequests={};
	this.selectServer(isDev);
	this.openRequests = 0;
}

function https() {
	if (window.location.protocol=="http:")
		return "http:";
	return "https:";
}

// Select/switch which server to use (dev or normal)
// this should clear internal cache etc.
// todo: maybe allow switching signed in accounts
Myself.prototype.selectServer = function(isDev) {
	this.logOut(true);
	if (isDev) {
		this.server = https() + "//newdev.smilebasicsource.com/api";
		this.lsKey = "devauth"
	} else {
		this.server = https() + "//new.smilebasicsource.com/api";
		this.lsKey = "auth"
	}
}

Myself.prototype.request = function(url, method, callback, data, cancel) {
	var $=this;
	$.openRequests++;
	$.loadStart(!!cancel);
	return sbs2Request($.server+"/"+url, method, function(e, resp) {
		$.openRequests--;
		$.loadEnd(!!cancel, e);
		/*if (e=='auth') {
			$.logOut();
		}*/
		$.cb(callback, e, resp);
	}, data, $.auth, cancel);
}

Myself.prototype.loadStart = function(lp) {
	if (this.onLoadStart)
		this.cb(this.onLoadStart, lp);
}

Myself.prototype.loadEnd = function(lp, e) {
	if (this.onLoadEnd)
		this.cb(this.onLoadEnd, lp, e);
}

Myself.prototype.getUsers = function(query, page, callback) {
	var $=this;
	query.limit = 20;
	query.skip = page * query.limit;
	$.readSimple("User"+queryString(query), 'user', function(e, resp){
		if (!e){
			$.cb(callback, resp);
		}
	});
}

// Most requests will be done through the chain endpoint with Myself.read
// However, if you want to use another endpoint (or if the request can't be chained (ex: /user/me)
// you can use this function, as long as
// the response is always an array of objects of the specified type
Myself.prototype.readSimple = function(url, type, callback) {
	var $=this;
	return $.request(url, 'GET', function(e, resp) {
		if (!e) {
			var obj = {};
			resp instanceof Array || (resp = [resp]);
			obj[type] = resp;
			$.handle(e, obj);
			$.cb(callback, e, resp);
		} else {
			$.cb(callback, e, resp);
		}
	});
}

Myself.prototype.read = function(requests, filters, callback, cancel) {
	var $=this;
	var query = {};
	query.requests = requests.map(function(req) {
		if (typeof req == 'string') {
			return req;
		} else {
			var type = Object.keys(req)[0];
			return type+"-"+JSON.stringify(req[type]);
		}
	});
	for (var filter in filters)
		query[filter] = filters[filter];
	var needCategorys = !$.categoryTree && query.requests.length<5;
	if (needCategorys) {
		query.requests.push('category~tree');
	}
	
	return $.request("Read/chain"+queryString(query), 'GET', function(e, resp) {
		if (needCategorys) {
			$.categoryTree = buildCategoryTree(resp.tree);
		}
		$.handle(e, resp);
		$.cb(callback, e, resp);
	}, undefined, cancel);
};

Myself.prototype.listen = function(requests, filters, callback, cancel) {
	var $=this;
	var query = {};
	
	requests.forEach(function(req) {
		var type = Object.keys(req)[0];
		query[type]=JSON.stringify(req[type]);
	});
	for (var filter in filters)
		query[filter] = filters[filter];
	
	return $.request("Read/listen"+queryString(query), 'GET', function(e, resp) {
		if (!e)
			$.handle(e, resp.chains);
		$.cb(callback, e, resp);
	}, undefined, cancel);
};

Myself.prototype.getUser = function(id, callback) {
	var $=this;
	return $.readSimple("User"+queryString(id), 'user', function(e, resp) {
		if (!e) {
			$.cb(callback, resp[0]);
		} else {
			$.cb(callback, null);
		}
	});
}

Myself.prototype.handle = function(e, resp) {
	var $=this;
	if (e)
		return;
	// form user id map and generate user avatar urls
	var userMap = {};
	resp.user && resp.user.forEach(function(user) {
		if (user.avatar && user.avatar != 125) {
			user.avatarURL = $.server+"/File/raw/"+user.avatar+"?size=120&crop=true";
			user.bigAvatarURL = $.server+"/File/raw/"+user.avatar+"?size=400&crop=true";
			user.rawAvatarURL = $.server+"/File/raw/"+user.avatar;
		} else {
			user.avatarURL = user.bigAvatarURL = user.rawAvatarURL = "./avatar.png";
		}
		var uid = user.id;
		if (uid) {
			if (uid == $.uid)
				$.me = user;
			userMap[uid] = user;
			$.userCache[uid] = user;
			
			if ($.userRequests[uid]) {
				$.userRequests[uid].forEach(function(func) {
					$.cb(func, user);
				});
				$.userRequests[uid] = undefined;
			}
		}
	});
	resp.userMap = userMap;
	// parse dates
	// (TODO)
}

////////////////////

Myself.prototype.logOut = function(soft) {
	if (this.auth) {
		this.auth = 'undefined'
		if (!soft) {
			localStorage.removeItem(this.lsKey);
		}
		if (this.onLogout)
			this.onLogout(this);
	}
}

// handle auth token once recieved
// also calculates your own UID (thank you random â¥)
Myself.prototype.setAuth = function(auth) {
	this.auth = auth;
	var x = JSON.parse(atob(auth.split(".")[1]));
	this.uid = +x.uid;
	if (this.onLogin)
		this.onLogin(this);
}

// run callback function
// this.cb(func, args...) is the same as
// if (func) func.call(this, args...)
Myself.prototype.cb = function(func) {
	if (func)
		func.apply(this, Array.prototype.slice.call(arguments, 1));
	else
		console.warn("Unbound callback", arguments);
}

// request auth token from username+password
Myself.prototype.logIn = function(username, password, callback) {
	var $=this;
	return $.request("User/authenticate", 'POST', function(e, resp) {
		if (!e) {
			$.setAuth(resp);
			localStorage.setItem($.lsKey, resp);
			$.readSimple("User/me", 'user', callback);
		}
		$.cb(callback, e, resp);
	}, {username: username, password: password});
}

// try to log in with cached auth token
// if cached token is found,
//  the function returns true and tests the token by requesting api/User/me
//  and `callback` will be called once this test is finished
// if there's no cached token, it returns false and DOES NOT CALL `callback`
Myself.prototype.loadCachedAuth = function(callback) {
	var $=this;
	var cached = localStorage.getItem($.lsKey);
	if (cached) {
		$.setAuth(cached);
		$.readSimple("User/me", 'user', function(e, resp){
			if (e == 'auth' || e == 'error') {
				$.logOut(); //auth was invalid
			}
			$.cb(callback, e, resp);
		}); //this is used to test the auth
		return true;
	}
	return false;
}

Myself.prototype.getPage = function(id, callback) {
	var $=this;
	id = +id;
	return $.read([
		{content: {ids: [id]}},
		{comment: {parentIds: [id], limit: 50, reverse: true}},
		"user.0createUserId.0editUserId.1createUserId.1editUserId",
	], {
		user: "id,username,avatar"
	}, function(e, resp) {
		if (!e) {
			var page = resp.content[0];
			if (page)
				$.cb(callback, page, resp.userMap, resp.comment, resp.old);
			else
				$.cb(callback, null, {}, [], []);
		}
	});
}

Myself.prototype.getDiscussion = function(id, callback) {
	var $=this;
	id = +id;
	return $.read([
		{content: {ids: [id]}},
		{comment: {parentIds: [id], limit: 30, reverse: true}},
		"user.0createUserId.0editUserId.1createUserId.1editUserId",
	], {
		user: "id,username,avatar"
	}, function(e, resp) {
		if (!e) {
			var page = resp.content[0];
			if (page)
				$.cb(callback, page, resp.comment.reverse(), resp.userMap);
			else
				$.cb(callback, null, [], {});
		}
	});
}

// This runs a callback when a user object is available
// it doesn't do any requests itself, so you need to do that separately before or after
Myself.prototype.whenUser = function(id, callback) {
	if (this.userCache[id]) {
		this.cb(callback, this.userCache[id]);
	} else if (this.userRequests[id]) {
		this.userRequests[id].push(callback);
	} else {
		this.userRequests[id] = [callback];
	}
}

Myself.prototype.getCategories = function(callback) {
	var $=this;
	return $.read([
		'category'
	], {
		category: "id,name,description,parentId"
	}, function(e, resp) {
		if (!e) {
			var tree = buildCategoryTree(resp.category);
			$.cb(callback, tree);
		}
	});
}

var rootCategory = {
	name: "[root]",
	id: 0,
	values: {},
}

// get the pages in a category
Myself.prototype.getCategory = function(id, page, callback, pinnedCallback) {
	id=+id;
	var $=this;
	var search = {
		parentIds: [id],
		limit: 10,
		skip: page*10,
		sort: 'editDate',
		reverse: true
	}
	if (id)
		var childCategorysFilter = {parentIds: [id]};
	else
		childCategorysFilter = {};
	var reading = [
		{content: search},
		{category: {ids: [id]}},
		{category: childCategorysFilter},
		"user.0createUserId"
	];
	
	var pinned, req2;
	if (id) {
		if ($.categoryTree) {
			var values = $.categoryTree.map[id].values;
			if (values.pinned) {
				pinned = values.pinned.split(",").map(function(x){return +x});
				reading[3] = {"content~pinned": {ids: pinned}};
				reading[4] = "user.0createUserId.3createUserId";
			}
		} else {
			req2 = true;
		}
	}
	
	return $.read(reading, {
		content: "id,name,parentId,createUserId,editDate,permissions",
		/*category: "id,name,description,parentId,values",*/
		user: "id,username,avatar"
	}, function(e, resp) {
		if (!e) {
			var category;
			var childs = [];
			resp.category.forEach(function(cat) {
				if (cat.parentId == id)
					childs.push(cat);
				if (cat.id == id)
					category = cat;
			});
			var pages = resp.content;
			//if (req2) {
			if (id) {
				var values = category.values;
				if (values.pinned) {
					pinned = values.pinned.split(",").map(function(x){return +x});
					$.readSimple("Content"+queryString({ids: pinned}), 'content', function(e, resp) {
						if (!e) {
							pinnedCallback(resp)
						}
					});
				}
			}
			//}
			if (pinned)
				var pinnedPages = resp.pinned;
			if (req2)
				pinnedPages = null; //nO
			// so here's an idea.
			// with the first request, we get some pages, right
			// our pinned pages MAY be included in there, depending on
			// what info we knew, and if any were in the search.
			// so, even if we couldn't specifically request the pinned pages,
			// we still might get some! and can return that info, perhaps..
			
			if (id==0) {
				$.cb(callback, rootCategory, childs, pages, resp.userMap, pinnedPages);
			} else if (category)
				$.cb(callback, category, childs, pages, resp.userMap, pinnedPages);
			else
				$.cb(callback, null, childs, pages, resp.userMap, pinnedPages);
		}
	});
}

Myself.prototype.getNotifications = function(callback) {
	var $=this;
	return $.read([
		{activityaggregate: {contentLimit: {watches: true}}},
		{commentaggregate: {contentLimit: {watches: true}}},
		"watch",
		"content.0id.1id.2contentId",
		"user.0userIds.1userIds.3createUserId.2userId"
	],{
		content: "id,name,parentId,createUserId,permissions",
		watch: "contentId,lastNotificationId,id",
		user: "id,avatar,super,special,username"
	}, function(e, resp) {
		$.cb(callback, e, resp);
	});
}

Myself.prototype.getPageForEditing = function(id, callback) {
	var $=this;
	if (id) {
		id = +id;
		return $.read([
			{content: {ids: [id]}},
			"user.0createUserId.0editUserId",
		], {
			user: "id,username,avatar"
		}, function(e, resp) {
			if (!e) {
				var page = resp.content[0];
				if (page)
					$.cb(callback, page, resp.userMap);
				else
					$.cb(callback, null, {});
			}
		});
	} else {
		if ($.categoryTree) {
			$.cb(callback, null, {});
		} else {
			return $.readSimple("Category", 'category', function(e, resp) {
				$.categoryTree = buildCategoryTree(resp);
				$.cb(callback, null, {});
			});
		}
	}
}

Myself.prototype.getCategoryForEditing = function(id, callback) {
	var $=this;
	if (id) {
		id = +id;
		return $.read([
			{category: {ids: [id]}},
		], {
		}, function(e, resp) {
			if (!e) {
				var cat = resp.category[0];
				if (cat)
					$.cb(callback, cat);
				else
					$.cb(callback, null);
			}
		});
	} else {
		if ($.categoryTree) {
			$.cb(callback, null, {});
		} else {
			return $.readSimple("Category", 'category', function(e, resp) {
				$.categoryTree = buildCategoryTree(resp);
				$.cb(callback, null, {});
			});
		}
	}
}

Myself.prototype.setVariable = function(name, value, callback) {
	var s = new String(value);
	s.constructor = Object;
	return this.request("Variable/"+name, 'POST', callback, s);
}

Myself.prototype.getVariable = function(name, callback) {
	var $=this;
	return this.request("Variable/"+name, 'GET', function(e, resp){
		if (!e) {
			$.cb(callback, resp);
		} else
			$.cb(callback, null);
	});
}

Myself.prototype.doListenInitial = function(callback) {
	var $=this;
	return $.read([
		{comment:{reverse:true,limit:10}},
		{activity:{reverse:true,limit:10}},
		"content.0parentId.1contentId", //pages
		"user.0createUserId.1userId" //users for comment and activity
	],{content:"id,createUserId,name,permissions"},callback);
}

Myself.prototype.doListen = function(lastId, statuses, lastListeners, clearNotifs, cancel, callback) {
	var $=this;
	var actions = {
		lastId: lastId,
		statuses: statuses,
		chains: [
			"comment.0id","activity.0id","watch.0id", //new stuff
			"content.1parentId.2contentId.3contentId", //pages
			"user.1createUserId.2userId" //users for comment and activity
		]
	}
	if (clearNotifs)
		actions.clearNotifictions = clearNotifs;
	var req = [
		{actions: actions}
	];
	if (Object.keys(lastListeners).length) {
		req.push({listeners: {
			lastListeners: lastListeners,
			chains: ["user.0listeners"]
		}});
	}
	return $.listen(req, {
		content: "id,createUserId,name,permissions"
	}, callback, cancel);
}
// todo:
// when logging in on a page, re-request the page data (along with your own user data)
// make a function for this
// it needs to handle all page types, hmm


Myself.prototype.postPage = function(page, callback) {
	if (page.id) {
		this.request("Content/"+page.id, 'PUT', callback, page);
	} else {
		this.request("Content", 'POST', callback, page);
	}
}

Myself.prototype.postCategory = function(cat, callback) {
	if (cat.id) {
		this.request("Category/"+cat.id, 'PUT', callback, cat);
	} else {
		this.request("Category", 'POST', callback, cat);
	}
}

Myself.prototype.deletePage = function(id, callback) {
	this.request("Content/"+id+"/delete", 'POST', callback);
}

Myself.prototype.postComment = function(id, message, f, callback) {
	this.request("Comment", 'POST', callback, {
		parentId: id,
		content: f+"\n"+message,
	});
};

Myself.prototype.setWatch = function(id, state, callback) {
	if (state)
		this.request("Watch/"+id, 'POST', callback);
	else
		this.request("Watch/"+id+"/delete", 'POST', callback);
};

Myself.prototype.getWatch = function(query, callback) {
	return this.request("Watch"+queryString(query), 'GET', callback);
}

Myself.prototype.setVote = function(id, state, callback) {
	return this.request("Vote/"+id+"/"+(state||"delete"), 'POST', callback);
}

Myself.prototype.getVote = function(query, callback) {
	return this.request("Vote"+queryString(query), 'GET', callback);
}

Myself.prototype.register = function(username, password, email, callback) {
	this.request("User/register", 'POST', callback, {
		username: username,
		password: password,
		email: email
	});
}

Myself.prototype.setSensitive = function(data, callback) {
	this.request("User/sensitive", 'POST', callback, data);
}

Myself.prototype.sendEmail = function(email, callback) {
	this.request("User/register/sendemail", 'POST', callback, {
		email: email
	});
}

Myself.prototype.confirmRegister = function(key, callback) {
	var $=this;
	return $.request("User/register/confirm", 'POST', function(e, resp) {
		if (!e) {
			$.setAuth(resp);
			localStorage.setItem($.lsKey, resp);
			$.readSimple("User/me", 'user', function(){});
		}
		$.cb(callback, e, resp);
	}, {
		confirmationKey: key
	});
}

Myself.prototype.getSettings = function(callback) {
	var $=this;
	if (me.auth) {
		return $.read([
			{user: {ids: [$.uid]}},
			{content: {createUserIds: [$.uid], type: '@user.page', limit: 1}},
		], {
			content: "id"
		}, function(e, resp) {
			if (!e && resp.user && resp.user[0]) {
				$.cb(callback, resp.user[0], resp.content[0]);
			} else {
				$.cb(callback, null, null);
			}
		});
	} else {
		$.cb(callback, null);
	}
}

Myself.prototype.fileUrl = function(id) {
	return this.server+"/File/raw/"+id;
}

Myself.prototype.uploadFile = function(file, callback) {
	var form = new FormData();
	form.append('file', file);
	this.request("File", 'POST', callback, form);
}

Myself.prototype.setBasic = function(data, callback) {
	this.request("User/basic", 'PUT', callback, data);
}

Myself.prototype.getActivity = function(page, callback) {
	var $=this;
	var day = 1000*60*60*24
	var start = new Date(Date.now() - day*(page+1)).toISOString();
	// "except no that won't work if site dies lol"
	var end = new Date(Date.now() - day*page).toISOString();
	var reading = [
		{activity: {createStart: start, createEnd: end}},
		{commentaggregate: {createStart: start, createEnd: end}},
		"content.0contentId.1id",
		"user.0userId.1userIds"
	]
	/*if ($.categoryTree)
		reading.push("category.0contentId");*/
	return $.read(reading, {
		content: "name,id,permissions"
	},function(e, resp) {
		if (!e) {
			$.cb(callback, resp.activity, resp.commentaggregate, resp.content, resp.userMap)
		} else {
			$.cb(callback, null, null, null, {});
		}
	});
}

Myself.prototype.getFiles = function(query, page, callback) {
	var $=this;
	query.limit = 20;
	query.skip = page*query.limit;
	query.reverse = true;
	return $.read([
		{file: query},
		"user.0createUserId"
	],{},function(e, resp) {
		if (!e) {
			$.cb(callback, resp.file, resp.userMap);
		} else {
			$.cb(callback, null, {});
		}
	});
}

// load next 10 comments older than `start`
Myself.prototype.loadCommentsBefore = function(id, start, callback) {
	var $=this;
	return $.read([
		{comment: {parentIds: [id], maxId: id-1, reverse: true, limit: 10}},
		"user.0createUserId"
	], {}, function(e, resp) {
		if (!e) {
			$.cb(callback, resp.comment, resp.userMap);
		}
	})
}

// load next 10 comments newer than `start`
Myself.prototype.loadCommentsAfter = function(id, start, callback) {
	var $=this;
	return $.read([
		{comment: {parentIds: [id], minId: id+1, limit: 10}},
		"user.0createUserId"
	], {}, function(e, resp) {
		if (!e) {
			$.cb(callback, resp.comment, resp.userMap);
		}
	})
}

// load comments between min and max, and 10 on either side
Myself.prototype.loadCommentsNear = function(id, min, max, callback) {
	var $=this;
	var query;
	if (max != min) {
		query = [
			{comment: {parentIds: [id], minId: min, maxId: max}},
			{comment: {parentIds: [id], maxId: min-1, reverse: true, limit: 10}},
			{comment: {parentIds: [id], minId: max+1, limit: 10}},
			"user.0createUserId.1createUserId.2createUserId"
		]
	} else  {
		query = [
			{comment: {parentIds: [id], maxId: min-1, reverse: true, limit: 10}},
			{comment: {parentIds: [id], minId: max, limit: 11}},
			"user.0createUserId.1createUserId"
		]
	}
	return $.read(query, {}, function(e, resp) {
		if (!e) {
			$.cb(callback, resp.comment, resp.userMap);
		}
	})
}

Myself.prototype.thumbnailURL = function(id) {
	return this.server+"/File/raw/"+id+"?size=50";
}

Myself.prototype.avatarURL = function(id) {
	return this.server+"/File/raw/"+id+"?size=120";
}

Myself.prototype.imageURL = function(id) {
	return this.server+"/File/raw/"+id;
}

Myself.prototype.putFile = function(file, callback) {
	return this.request("File/"+file.id, 'PUT', callback, file);
}

Myself.prototype.getUserPage = function(id, callback) {
	var $=this;
	id = +id;
	return $.read([
		{user: {userIds: [id]}},
		{content: {createUserIds: [id], type: '@user.page', limit: 1}}, //page
		{activity: {userIds: [id], limit: 20, reverse: true}},
		{commentaggregate: {userIds: [id], limit: 100, reverse: true}},
		"content.2contentId.3id"
	], {
	}, function(e, resp) {
		if (!e) {
			var user = resp.userMap[id];
			// ugh need to make
			// content map now
			// to map Content to Activity
			// you know, maybe this could be done automatically.... somehow
			if (user) {
				var page = resp.content[0];
				if (page && page.type != "@user.page")
					page = undefined;
				$.cb(callback, user, page, resp.activity, resp.commentaggregate, resp.content, resp.userMap);
			} else
				$.cb(callback, null, {}, [], [], [], {});
		}
	});
	// what we need:
	// user object
	// user page
	// recent activity + assoc contentz
	// recent comment aggregate + assoc contentz
}

function buildCategoryTree(categories) {
	var root = {childs: [], id: 0, name: "[root]", values: {}};
	var orphans = [];
	var map = {
		'0': root
	};
	root.map = map;
	categories = categories.map(function(cat) {
		var n = Object.assign({}, cat); //copy
		n.childs = [];
		map[n.id] = n;
		return n
	});
	categories.forEach(function(cat) {
		if (cat.parentId < 0)
			cat.parentId = 0;
		var parent = map[cat.parentId];
		if (parent) {
			cat.parent = parent;
			parent.childs.push(cat);
		} else {
			orphans.push(cat);
		}
	});
	return root;
}

// so if I was a Good Programmer I would
// make Classes for every data type
// and either
// - have functions to convert to/from the native format
// - or store the raw data separately from extra data (better)
// but none of this will ever really work because
// field filtering, etc.
// nothing   is real
function LongPoller(myself) {
	this.myself = myself;
	this.cancel = [function(){}];
	this.lastListeners = {};
	this.lastId = -1;
	this.statuses = {};
}

LongPoller.prototype.start = function() {
	this.loop();
}

LongPoller.prototype.setState = function(text, state) {
	this.running = state;
	this.onStatus.call(this, text);
}

LongPoller.prototype.loop = function() {
	var $=this;
	$.setState("Idle (waiting)", true);//idle
	$.myself.doListen($.lastId, $.statuses, $.lastListeners, undefined, this.cancel, function(e, resp) {
		$.setState("Handling response", false);
		if (!e) {
			$.lastId = resp.lastId;
			if (resp.listeners) {
				$.lastListeners = resp.listeners;
				$.onListeners.call(this, resp.listeners, resp.chains.userMap);
			}
			var pageMap = {};
			resp.chains.content && resp.chains.content.forEach(function(page) {
				pageMap[page.id] = page;
			});
			if (resp.chains && resp.chains.comment) {
				$.onMessages.call(this, resp.chains.comment, resp.chains.userMap, pageMap);
			}
			if (resp.chains && resp.chains.activity) {
				$.onActivity.call(this, resp.chains.activity, resp.chains.userMap, pageMap);
			}
			$.onBoth.call(this, resp);
		}
		if (!e || e=='timeout') {
			$.setState("Queueing next request", true);
			var t = setTimeout(function() {
				$.loop();
			}, 0);
			$.cancel = [function() {
				clearTimeout(t);
			}]
		} else {
			$.setState("Error!", false);
			alert("LONG POLLER FAILED:"+resp);
			console.log("LONG POLLED FAILED", e, resp);
		}
	});
}

LongPoller.prototype.refresh = function() {
	if (this.running) {
		this.cancel[0]();
		this.loop();
	}
}

LongPoller.prototype.setViewing = function(id) {
	if (this.viewing) {
		delete this.lastListeners[this.viewing];
		delete this.statuses[this.viewing];
	}
	this.lastListeners[id] = {"0":""};
	this.statuses[id] = "active";
	this.viewing = id;
	this.refresh();
}
var highlight_smilebasic = (function(){
	//keywords that don't have an expression after them
	var keywords=[
		"BREAK","COMMON","CONTINUE","ELSE","END","ENDIF","REM","REPEAT","THEN","WEND",
	];
	var keywords_sb3=[
		"STOP"	
	];
	var keywords_sb4=[
		"OTHERWISE","ENDCASE","LOOP","ENDLOOP"
	];
	//keywords w/ expression after them (or other special thing)
	var argKeywords=[
		"CALL","DATA","DEC","DIM","ELSEIF","EXEC","FOR","GOSUB","GOTO","IF","INC","INPUT","LINPUT","NEXT","ON","OUT","PRINT","READ","RESTORE","RETURN","SWAP","UNTIL","USE","VAR","WHILE",
	];
	var argKeywords_sb4=[
		"CASE","WHEN","DEFOUT","TPRINT","CONST","ENUM",
	];
	var builtinFunctions=[
		"ABS","ACCEL","ACLS","ACOS","ARYOP","ASC","ASIN","ATAN","ATTR","BACKCOLOR","BEEP","BGMCHK","BGMCLEAR","BGMCONT","BGMPAUSE","BGMPLAY","BGMSET","BGMSETD","BGMSTOP","BGMVAR","BGMVOL","BIN$","BIQUAD","BQPARAM","BREPEAT","BUTTON","CEIL","CHKCALL","CHKCHR","CHKFILE","CHKLABEL","CHKMML","CHKVAR","CHR$","CLASSIFY","CLIPBOARD","CLS","COLOR","CONTROLLER","COPY","COS","COSH","DEG","DELETE","DIALOG","DTREAD","EFCSET","EFCWET","EXP","FADE","FADECHK","FFT","FFTWFN","FILES","FILL","FLOOR","FORMAT$","GBOX","GCIRCLE","GCLIP","GCLS","GCOLOR","GCOPY","GFILL","GLINE","GLOAD","GPAINT","GPSET","GPUTCHR","GSAVE","GTRI","GYROA","GYROSYNC","GYROV","HEX$","IFFT","INKEY$","INSTR","KEY","LEFT$","LEN","LOAD","LOCATE","LOG","MAX","MID$","MIN","OPTION","PCMCONT","PCMSTOP","PCMSTREAM","PCMVOL","POP","POW","PRGDEL","PRGEDIT","PRGGET$","PRGINS","PRGNAME$","PRGSET","PRGSIZE","PROJECT","PUSH","RAD","RANDOMIZE","RENAME","RGB","RIGHT$","RINGCOPY","RND","RNDF","ROUND","RSORT","SAVE","SCROLL","SGN","SHIFT","SIN","SINH","SNDSTOP","SORT","SPANIM","SPCHK","SPCHR","SPCLR","SPCOL","SPCOLOR","SPCOLVEC","SPDEF","SPFUNC","SPHIDE","SPHITINFO","SPHITRC","SPHITSP","SPHOME","SPLINK","SPOFS","SPPAGE","SPROT","SPSCALE","SPSET","SPSHOW","SPSTART","SPSTOP","SPUNLINK","SPUSED","SPVAR","SQR","STICK","STR$","SUBST$","TALK","TALKCHK","TALKSTOP","TAN","TANH","TMREAD","TOUCH","UNSHIFT","VAL","VSYNC","WAIT","WAVSET","WAVSETA","XSCREEN",
		//BIG+SB4
		"VIBRATE",
	];
	var builtinFunctions_sb3=[
		"BACKTRACE","BGANIM","BGCHK","BGCLIP","BGCLR","BGCOLOR","BGCOORD","BGCOPY","BGFILL","BGFUNC","BGGET","BGHIDE","BGHOME","BGLOAD","BGOFS","BGPAGE","BGPUT","BGROT","BGSAVE","BGSCALE","BGSCREEN","BGSHOW","BGSTART","BGSTOP","BGVAR","BGMPRG","BGMPRGA","DISPLAY","DLCOPEN","EFCOFF","EFCON","FONTDEF","GOFS","GPAGE","GPRIO","GSPOIT","MICDATA","MICSAVE","MICSTART","MICSTOP","MPEND","MPGET","MPNAME$","MPRECV","MPSEND","MPSET","MPSTART","MPSTAT","STICKEX","RGBREAD","SPCLIP","VISIBLE","WIDTH","XOFF","XON",
		//BIG
		"GPUTCHR16",
	];
	var builtinFunctions_sb4=[
		"PCMPOS","TYPEOF","ARRAY#","ARRAY%","ARRAY$","RESIZE","INSERT","REMOVE","INSPECT","DEFARGC","DEFARG","DEFOUTC","INT","FLOAT","LAST","FONTINFO","PERFBEGIN","PERFEND","SYSPARAM","METAEDIT","METALOAD","METASAVE","XCTRLSTYLE","MOUSE","MBUTTON","IRSTART","IRSTOP","IRSTATE","IRREAD","IRSPRITE","KEYBOARD","TCPIANO","TCHOUSE","TCROBOT","TCFISHING","TCBIKE","TCVISOR","LOADG","LOADV","SAVEG","SAVEV","ANIMDEF","TSCREEN","TPAGE","TCOLOR","TLAYER","TPUT","TFILL","THOME","TOFS","TROT","TSCALE","TSHOW","THIDE","TBLEND","TANIM","TSTOP","TSTART","TCHK","TVAR","TCOPY","TSAVE","TLOAD","TARRAY","TUPDATE","TFUNC","GTARGET","RGBF","HSV","GPGET","GARRAY","GUPDATE","GSAMPLE","SPLAYER","STOP","LAYER","LMATRIX","LFILTER","LCLIP","BEEPPIT","BEEPPAN","BEEPVOL","BEEPSTOP","BGMPITCH","BGMWET","EFCEN","SNDMSBAL","SNDMVOL","PRGSEEK","XSUBSCREEN","ENVSTAT","ENVTYPE","ENVLOAD","ENVSAVE","ENVINPUT$","ENVFOCUS","ENVPROJECT","ENVLOCATE","PUSHKEY","HELPGET","HELPINFO","UISTATE","UIMASK","UIPUSHCMPL","DATE$","TIME$","RESULT","CALLIDX","FREEMEM","MILLISEC","MAINCNT",
	];
	//SB3 only
	var systemVariables=["CALLIDX","CSRX","CSRY","CSRZ","DATE$","ERRLINE","ERRNUM","ERRPRG","EXTFEATURE","FREEMEM","HARDWARE","MAINCNT","MICPOS","MICSIZE","MILLISEC","MPCOUNT","MPHOST","MPLOCAL","PCMPOS","PRGSLOT","RESULT","SYSBEEP","TABSTEP","VERSION"];
	
	function isAlpha(c){
		return c>='A'&&c<='Z'||c>='a'&&c<='z';
	}
	
	function isDigit(c){
		return c>='0'&&c<='9';
	}
	
	//token types:
	//"linebreak"  - line break
	//"function"   - function call
	//"operator"   - operators, including word operators
	//"name"       - function name (after DEF keyword)
	//"equals"     - = assignment operator
	//"expr"       - ; or , or ( or [
	//"noexpr"     - : or ) or ]
	//"whitespace" - space or tab
	//"variable"   - variable
	//"number"     - number literal (including TRUE/FALSE)
	//"def"        - DEF keyword
	//"string"     - strings (including label strings)
	//"word"       - unknown word (resolved to "function", "operator", "name", "variable", "def", "argkeyword", or "keyword")
	//"label"      - unknown label/labelstring (resolved to "label" or "string"), or label (not label string)
	//"argkeyword" - keyword with expression after it
	//"keyword"    - keyword that doesn't have an expression after it
	
	function isInExpr(type){
		return type=="argkeyword"||type=="function"||type=="operator"||type=="name"||type=="equals"||type=="expr";
	}
	
	return function(code, callback, sb4){
		var i=-1,c;
		function next(){
			i++;
			c=code.charAt(i);
		}

		function jump(pos){
			i=pos-1;
			next();
		}
		
		var prev=0;
		var prevType="start";
		
		//=================//
		// Process a token //
		//=================//
		function push(type, cssType){
			var word=code.substring(prev,i);
			prev=i;
			//Check words
			if(type=="word"){
				var upper=word.toUpperCase();
				//True/False
				if(sb4!=true && (upper=="TRUE"||upper=="FALSE")){
					type="number";
					cssType="true-false number";
				//operators
				}else if(upper=="DIV"||upper=="MOD"||upper=="AND"||upper=="OR"||upper=="XOR"||upper=="NOT"){
					type="operator";
					cssType="word-operator operator";
				//DEF
				}else if(upper=="DEF"){
					type="def";
					cssType="def keyword";
				//T? TPRINT
				}else if(sb4!=false && (upper=="T" && c=='?')){
					word+=c;
					next();
					prev=i;
					type="keyword";
					cssType="keyword";
				//keywords without an expression after them
				}else if(keywords.indexOf(upper)>=0 || sb4==false && keywords_sb3.indexOf(upper)>=0 || sb4!=false && keywords_sb4.indexOf(upper)>=0){
					type="keyword";
					cssType="keyword";
				//keywords w/ and expression after
				}else if(argKeywords.indexOf(upper)>=0 || sb4!=false && argKeywords_sb4.indexOf(upper)>=0){
					type="argkeyword";
					cssType="keyword";
				//User-defined function name
				}else if(prevType=="def"){
					type="name";
					cssType="name";
				//Variable, function, TO/STEP, etc.
				}else{
					var fPos=i;
					while(c==' ' || c=='\t')
						next();
					var isFunc=false;
					if(isInExpr(prevType)){
						if(c=="(")
							isFunc=true;
					}else{
						isFunc=true;
						if(c=="["){
							isFunc=false;
						}else if(c=="="){
							next();
							if(c!="=")
								isFunc=false;
						}
					}
					if(isFunc){
						type="function";
						if(builtinFunctions.indexOf(upper)!=-1 || sb4!=true && builtinFunctions_sb3.indexOf(upper)!=-1 || sb4!=false && builtinFunctions_sb4.indexOf(upper)!=-1)
							cssType="statement function";
						else if(upper=="TO" || upper=="STEP")
							cssType="to-step keyword";
						else
							cssType="statement";
					}else{
						type="variable"
						if(sb4!=true && systemVariables.indexOf(upper)!=-1)
							cssType="variable function";
						else
							cssType="variable";
					}
					jump(fPos);
				}
			//Check labels
			}else if(type=="label"){
				if(isInExpr(prevType)){
					type="string";
					cssType="label-string string";
				}else{
					cssType="label";
				}
			//Use type as csstype if not specified
			}else{
				if(cssType==undefined)
					cssType=type;
			}
			//pass to callback function
			callback(word,cssType);
			//store previous non-whitespace token type
			if(type!="whitespace")
				prevType=type;
		}
		
		next();
		
		//loop until the end of the string
		while(c){
			//
			//keywords, functions, variables
			//
			if(isAlpha(c)||c=='_'){
				next();
				//read name
				while(isAlpha(c)||isDigit(c)||c=='_')
					next();
				//read type suffix
				if(c=='#'||c=='%'||c=='$')
					next();
				//push word type
				push("word");
			//
			//numbers
			//
			}else if(isDigit(c)||c=='.'){
				//if digit was found, read all of them
				while(isDigit(c))
					next();
				//if there's a decimal point
				if(c=='.'){
					next();
					//read digits after
					if(isDigit(c)){
						next();
						while(isDigit(c))
							next();
					}else{
						//if GOTO is available: GOTO @skip_e
						if(c=='#')
							next();
						push("number");
						continue;
					}
				}
				//E notation
				if(c=='E'||c=='e'){
					var ePos=i;
					next();
					//check for + or -
					if(c=='+'||c=='-')
						next();
					//read digits
					if(isDigit(c)){
						next();
						while(isDigit(c))
							next();
					//no digits (invalid)
					}else{
						jump(ePos);
						push();
						continue;
					}
				}
				//(if GOTO is available: @skip_e)
				//read float suffix
				if(c=='#')
					next();
				push("number");
			//
			//strings
			//
			}else switch(c){
			case '"':
				next();
				//read characters until another quote, line ending, or end of input
				while(c && c!='"' && c!='\n' && c!='\r')
					next();
				//read closing quote
				if(c=='"')
					next();
				push("string");
			//
			//comments
			//
			break;case '\'':
				next();
				//read characters until line ending or end of input
				while(c && c!='\n' && c!='\r')
					next();
				push("comment");
			//
			//logical AND, hexadecimal, binary
			//
			break;case '&':
				next();
				switch(c){
				//logical and
				case '&':
					next();
					push("operator");
				//hexadecimal
				break;case 'H':case 'h':
					var hPos=i;
					next();
					//read hexadecimal digits
					if(isDigit(c)||c>='A'&&c<='F'||c>='a'&&c<='f'|| (c=='_'&&sb4!=false)){
						next();
						while(isDigit(c)||c>='A'&&c<='F'||c>='a'&&c<='f'|| (c=='_'&&sb4!=false))
							next();
						push("number");
					}else{
						jump(hPos);
						push();
					}
				//binary
				break;case 'B':case 'b':
					var bPos=i;
					next();
					//read hexadecimal digits
					if(c=='0'||c=='1'|| (c=='_'&&sb4!=false)){
						next();
						while(c=='0'||c=='1'|| (c=='_'&&sb4!=false))
							next();
						push("number");
					}else{
						jump(bPos);
						push();
					}
				//invalid &
				break;default:
					push();
				}
			//
			//labels
			//
			break;case '@':
				next();
				//read name
				while(isDigit(c)||isAlpha(c)||c=='_')
					next();
				//ok
				push("label");
			//
			//constants
			//
			break;case '#':
				next();
				//read name
				if(isDigit(c)||isAlpha(c)||c=='_'){
					next();
					while(isDigit(c)||isAlpha(c)||c=='_')
						next();
					//read type suffix
					if(c=='#'||c=='%'||c=='$')
						next();
					push("number","constant number");
				}else{
					//read type suffix
					if(c=='#'||c=='%'||c=='$'){
						next();
						push("number","constant number");
					}else{
						push();
					}
				}
			//
			//logical or
			//
			break;case '|':
				next();
				//logical or
				if(c=='|'){
					next();
					push("operator");
				//invalid
				}else{
					push();
				}
			//
			//less than, less than or equal, left shift
			//
			break;case '<':
				next();
				if(c=='='||c=='<') //<= <<
					next();
				push("operator");
			//
			//greater than, greater than or equal, right shift
			//
			break;case '>':
				next();
				if(c=='='||c=='>') //>= >>
					next();
				push("operator");
			//
			//equal, equal more
			//
			break;case '=':
				next();
				//==
				if(c=='='){
					next();
					push("operator");
				}else{
					push("equals");
				}
			//
			//logical not, not equal
			//
			break;case '!':
				next();
				if(c=='=') // !=
					next();
				push("operator");
			//
			//add, subtract, multiply, divide
			//
			break;case '+':case '-':case '*':case '/':
				next();
				push("operator");
			//
			// Line continuation (SB4)
			//
			break;case '\\':
				next();
				if (sb4==false) {
					push(undefined,false);
				} else {
					while (c && c!='\n' && c!='\r')
						next();
					next();
					push("whitespace")
				}
			
			//
			//other
			//
			
			break;case ';':case ',':case '[':case '(':
				next();
				push("expr",false);
			break;case '\n':
				next();
				push("linebreak",false);
			break;case ":":case ")":case "]":
				next();
				push("noexpr",false);
			break;case " ":case "\t":
				next();
				push("whitespace",false);
			break;case '?':
				next();
				push("argkeyword","question keyword");
			break;default:
				next();
				push(undefined,false);
			}
		}
		push("eof");
	}
})();

function highlightSB(text, lang) {
	function escapeHTML(text) {
		return text.replace(/&/g,"&amp;").replace(/</g,"&lt;");
	}
	
	if (lang)
		lang = lang.toLowerCase();
	
	var html="";
	
	if (!lang || lang == "sb3" || lang == "sb4" || lang == "sb") {
		if (lang == "sb4")
			lang = true;
		else if (lang == "sb3")
			lang = false;
		else
			lang = undefined;
		
		var prevType=false;
		//this is called for each highlightable token
		function callback(word, type) {
			if (word) {
				//only make a new span if the CSS class has changed
				if (type!=prevType) {
					//close previous span
					if (prevType)
						html += "</span>";
					//open new span
					if (type)
						html += "<span class=\""+type+"\">";
				}
				html += escapeHTML(word);
				prevType = type;
			}
		}
		
		highlight_smilebasic(text, callback, lang);
		//close last span
		if (prevType)
			html += "</span>";
	} else {
		html = escapeHTML(text);
	}
	
	return html;
}
var Parse = {
	lang:{}
};

// parser options
// this can be easily changed
// to control the output

// most functions should return an object containing:
//   .node or .nodes - the node(s) to insert
//   .branch - (optional if .node was specified) which node to insert children into
//   .block - `true` if the element is display: block or similar.

// most functions take input in the form of either
// (args) (or (args, contents) for things where the contents are plain text)
// (code blocks, [img], etc.)
// the unnamed argument uses a key of ""
// args without a value are set to true
// for example, `[tag=test key=value option]` would pass
// {"":"test", key:"value", option:true}
(function() {
	function create(x) {
		return document.createElement(x);
	}
	function createText(x) {
		return document.createTextNode(x);
	}
	function creator(tag) {
		return function() {
			return {node:create(tag)};
		}
	}
	function defaultProtocol() {
		if (window.location.protocol == 'http:')
			return 'http:';
		else
			return 'https:';
	}
	function getYoutubeID(url) {
		var match = url.match(/(?:https?:\/\/)?(?:www\.)?youtu\.?be(?:\.com)?\/?.*(?:watch|embed)?(?:.*v=|v\/|\/)([\w\-_]+)\&?/);
		if (match)
			return match[1];
		return null;
	}
	// returns [protocol, rest of url] or [null, url]
	function urlProtocol(url) {
		var match = url.match(/^([-\w]+:)([^]*)$/);
		if (match)
			return [match[1].toLowerCase(), match[2]];
		return [null, url];
	}

	// so normally our path structure will look like
	// url#path?query#fragment
	// with #s in the path and query escaped with %
	// however, some browsers escape duplicate #s automatically, so this has to be dealt with somehow
	// I'm not sure of a good way which still allows # to be used in the path+query, though
	// may need to use a different character...
	function getPath() {
		var hash = decodeURIComponent(location.hash.substr(1));
		return hash.split("#");
	}
	
	Parse.options = {
		append: function (parent, child) {
			parent = parent.branch || parent.node;

			if (child.nodes)
				child.nodes.forEach(function(x){
					parent.appendChild(x)
				});
			else
				parent.appendChild(child.node);
		},
		
		//========================
		// nodes without children:
		text: function(text) {
			return {node: createText(text)};
		},
		lineBreak: creator('br'),
		line: creator('hr'),
		// used for displaying invalid markup
		// reason is currently unused
		invalid: function(text, reason) {
			var node = create('span');
			node.className = 'invalid';
			node.title = reason;
			node.textContent = text;
			return {node:node};
		},
		// code block
		code: function(args, contents) {
			var language = args[""];
			var node = create('pre');
			node.setAttribute('data-lang', language);
			node.innerHTML = highlightSB(contents, language);
			return {block:true, node:node}
		},
		// inline code
		icode: function(args, contents) {
			var node = create('code');
			node.textContent = contents;
			return {node:node};
		},
		audio: function(args) {
			var node = create('audio');
			node.setAttribute('controls', "");
			node.setAttribute('src', args[""]);
			return {block:true, node:node};
		},
		video: function(args) {
			var url = args[""];
			var node = create('video');
			node.setAttribute('controls', "");
			node.setAttribute('src', url);
			return {block:true, node:node};
		},
		youtube: function(args) {
			var url = args[""];
			var protocol = defaultProtocol();
			var match = getYoutubeID(url);
			if (true) {
				var node = create('img');
				node.className = "youtube";
				if (match)
					node.src = protocol+"//i.ytimg.com/vi/"+match+"/mqdefault.jpg";
				return {block:true, node:node};
			} else {
				var node = create('iframe');
				node.className = "youtube";
				if (match)
					node.src = protocol+"//www.youtube-nocookie.com/embed/"+match;
				return {block:true, node:node};
			}
		},
		
		//=====================
		// nodes with children
		root: function() {
			var node = create('div');
			node.className = 'markup-root';
			return {block:true, node:node};
		},
		bold: creator('b'),
		italic: creator('i'),
		underline: creator('u'),
		strikethrough: creator('s'),
		heading: function(level) { // input: 1, 2, or 3
			// output: h2-h4
			return {block:true, node:create('h'+(level+1))};
		},
		
		quote: function(args) {
			// <blockquote><cite> arg </cite><br> ... </blockquote>
			var name = args[""];
			var node = create('blockquote');
			if (name) {
				var cite = create('cite');
				cite.textContent = name;
				node.appendChild(cite);
				node.appendChild(create('br'));
			}
			return {block:true, node:node};
		},
		list: function(args) {
			// <ul> ... </ul>
			if (args[""]!=undefined) {
				var list = create('ol');
				list.style.listStyleType = args[""];
			} else
				list = create('ul');
			return {block:true, node:list};
		},
		item: function(index) {
			return {block:true, node:create('li')};
		},
		//creator('li'), // (list item)
		
		link: function(args) {
			// <a href= url> ... </a>
			var url = args[""];
			// important, do not remove, prevents script injection
			if (/^ *javascript:/i.test(url))
				url = "";
			
			var node = create('a');
			
			var protocol = urlProtocol(url);
			if (protocol[0] == "sbs:") {
				// put your custom local url handling code here
				url = "#"+protocol[1];
			} else if (!protocol[0]) {
				if (url[0] == "#") {
					// put your fragment link handling code here
					var hash1 = getPath();
					var name = url.substr(1)
					hash = "#"+hash1[0]+"#"+name;
					url = hash;
					node.onclick = function(e) {
						var hash2 = getPath();
						if (hash1[0]==hash2[0] && hash2[1]==name) {
							var n = document.getElementsByName("_anchor_"+name);
							if (n[0])
								n[0].scrollIntoView();
							e.preventDefault();
						} else {
							window.location.hash = hash;
						}
					}
				} else {
					// urls without protocol get https:// or http:// added
					url = defaultProtocol()+"//"+url;
				}
			}
			node.setAttribute('href', url);
			return {node:node};
		},
		
		table: function(opts) {
			// <div class="tableContainer"><table> ... </table></div>
			var container = create('div');
			container.className = "tableContainer"
			var node = create('table');
			container.appendChild(node);
			return {
				block: true,
				node: container,
				branch: node
			}
		},
		
		row: creator('tr'),
		
		cell: function (opt) {
			// <td> ... </td> etc.
			var node = opt.h ?
				 create('th') :
				 create('td');
			if (opt.rs)
				node.rowSpan = opt.rs;
			if (opt.cs)
				node.colSpan = opt.cs;
			if (opt.c) {
				if (opt.c[0] == "#")
					node.style.backgroundColor = opt.c;
				node.setAttribute("data-bgcolor", opt.c);
			}
			if (opt.a) {
				node.style.textAlign = opt.a;
			}
			node.className = "cell";
			return {node:node};
		},
		
		image: function(args) {
			// <img src= arg tabindex="-1">
			var url = args[""];
			var node = create('img');
			node.setAttribute('src', url);
			node.setAttribute('tabindex', "-1");
			/*node.onload = function() {
			  if (window.scrollToAuto)
			  scrollToAuto();
			  }*/
			return {node:node, block:true};
		},
		
		// parser error message
		error: function(e, stack) {
			// <div class="error">Error while parsing:<pre> stack trace </pre>Please report this</div>
			var node = create('div');
			node.className = "error";
			node.appendChild(createText("Markup parsing error: "));
			var err = create('code')
			err.textContent = e;
			node.appendChild(err);
			node.appendChild(createText("\nPlease report this!"));
			if (stack) {
				var pre = create('pre');
				pre.textContent = stack;
				node.appendChild(pre);
			}
			return {node:node, block:true};
		},
		
		align: function(args) {
			var node = create('div');
			var arg = args[""];
			if (arg == 'left' || arg == 'right' || arg == 'center')
				node.style.textAlign = arg;
			return {node:node, block:true};
		},
		superscript: creator('sup'),
		subscript: creator('sub'),
		anchor: function(args) {
			var name = args[""];
			var node = create('a');
			// put your anchor name handler here
			// I prefix the names to avoid collision with node ids
			// which use the same namespace as name
			node.name = "_anchor_"+name;
			return {node:node, block:true};
		},
		spoiler: function(args) {
			// <button> arg </button><div class="spoiler"> ... </div>
			// I'd use <summary>/<details> but it's not widely supported
			// and impossible to style with css
			// this probably needs some aria attribute or whatever
			var button = create('button');
			button.onclick = function() {
				if (this.getAttribute('data-show') == null)
					this.setAttribute('data-show',"");
				else
					this.removeAttribute('data-show');
			}
			button.className = 'spoilerButton';
			var name = args[""];
			if (name == true)
				name = "spoiler";
			button.textContent = name;
			
			var box = create('div');
			box.className = "spoiler";
			
			return {
				block: true,
				nodes: [button, box],
				branch: box
			}
		}
	}
})();

(function(){
	/***********
	 ** STATE **
    ***********/
	var c,i,cache = {video:{},audio:{},youtube:{}},code;
	var skipNextLineBreak;
	var textBuffer;
	var curr, output;
	var stack;
	var startOfLine;
	var leadingSpaces;
	var blocks;
	function scan(){};

	function errorHandle(func) {
		try {
			func()
		} catch (e) {
			// todo: close all blocks and add error message
		}
	}
	
	function init(scanFunc, myBlocks, text) {
		scan = scanFunc;
		code = text;
		for (type in cache)
			for (arg in cache[type])
				cache[type][arg].forEach(function(x){
					x.used = false;
				});
		blocks = myBlocks;
		leadingSpaces = 0;
		startOfLine = true;
		skipnextLineBreak = false;
		textBuffer = "";
		output = curr = options.root();
		stack = [{node:curr, type:'root'}];
		stack.top = function() {
			return stack[stack.length-1];
		};
		restore(0);
	}
	// move to pos
	function restore(pos) {
		i = pos-1;
		scan();
	}

	//try to read a char
	function eatChar(chr) {
		if (c == chr) {
			scan();
			return true;
		}
	}

	function matchNext(str) {
		return code.substr(i, str.length) == str;
	}
	
	// read a url
	// if `allow` is true, url is only ended by end of file or ]] or ][ (TODO)
	function readUrl(allow) {
		var start = i;
		if (allow)
			while (c && c!="]" && c!="[")
				scan();
		else
			while (isUrlChar(c))
				scan();
		return code.substring(start, i);
	}

	
	// ew regex
	function isUrlChar(c) {
		// removed ) because interferes with stuff too much
		// other problems common are
		// - period, comma, etc. after url
		return c && (/[-\w\$\.+!*'(,;/\?:@=&#%]/).test(c);
	}
	/***********
    ** stack **
    ***********/
	function stackContains(type) {
		for (var i=0; i<stack.length; i++) {
			if (stack[i].type == type) {
				return true;
			}
		}
		return false;
	}
	function top_is(type) {
		var top = stack.top();
		return top && top.type == type;
	}
	
	/****************
    ** outputting **
    ****************/
	function endBlock() {
		flushText();
		var item = stack.pop();
		if (item.node && item.node.block)
			skipNextLineBreak = true;

		if (stack.length) {
			var i=stack.length-1;
			// this skips {} fake nodes
			// it will always find at least the root <div> element I hope
			while (!stack[i].node){
				i--;
			}
			curr = stack[i].node;
		} else {
			curr = null;
		}
	}
	
	// add simple block with no children
	function addBlock(node) {
		flushText();
		options.append(curr, node);
	}

	// output contents of text buffer
	function flushText() {
		if (textBuffer) {
			options.append(curr, options.text(textBuffer));
			textBuffer = "";
		}
	}

	// add linebreak to output
	// todo: skipping linebreaks should skip / *\n? */ (spaces before/after!)
	// so like [h1]test[/h1] [h2]test[/h2]
	// no extra linebreak there
	function addLineBreak() {
		if (skipNextLineBreak) {
			skipNextLineBreak = false;
		} else {
			flushText();
			addBlock(options.lineBreak());
		}
	}

	// add text to output (buffered)
	function addText(text) {
		if (text) {
			textBuffer += text;
			skipNextLineBreak = false;
		}
	}
	
	// call at end of parsing to flush output
	function endAll() {
		flushText();
		while (stack.length)
			endBlock();
	}
	
	/*****************
    ** cache stuff **
    *****************/
	function markCacheUnused() {
		for (type in cache)
			for (arg in cache[type])
				cache[type][arg].forEach(function(x){
					x.used = false;
				});
	}
	
	function findUnusedCached(cache, type, arg) {
		var list = cache[type][arg]
		if (!list)
			return null;
		for (var i=0;i<list.length;i++) {
			if (!list[i].used)
				return list[i];
		}
		return null;
	}

	function startBlock(type, data, arg) {
		data.type = type;
		if (type) {
			
			var node = tryGetCached(cache, type, arg, function() {
				return blocks[type](arg);
			});
			data.node = node;
			if (node.block)
				skipNextLineBreak = true;
			
			flushText();
			options.append(curr, node);
			curr = node;
		}
		stack.push(data);
		return data;
	}
	// check for /\b(http://|https://|sbs:)/ basically
	function isUrlStart() {
		if (code[i-1] && /\w/.test(code[i-1]))
			return false
		return matchNext("http://") || matchNext("https://") || matchNext("sbs:")
	}
	
	// try to get a node from cache.
	// will get nodes where `type` and `arg` matches
	// if not found, returns make(), and adds to cache
	function tryGetCached(cache, type, arg, make) {
		var node;
		if (cache && type && cache[type]) {
			var item = findUnusedCached(cache, type, arg);
			if (item) {
				item.used = true;
				node = item.node;
			}
		}
		if (!node && type) {
			node = make();
			if (cache && cache[type]) {
				if (!cache[type][arg])
					cache[type][arg] = [];
				cache[type][arg].push({node:node, used:true});
			}
		}
		return node;
	}

	var options = Parse.options;
	
	Parse.lang['12y'] = function(codeInput, preview) {
		// so what happens here is
		// when a video needs to be generated
		// first, check the cache. if it exists there, insert it
		// (remember that a node can only exist in one place in the DOM though)
		// now, if the video needs to be created, and preview mode is enabled,
		// a place holder is generated (and not stored in the cache)
		// if preview is disabled (and cache is passed), the video is generated
		// and stored in the cache, to be reused later
		
		// in the editor, this should be called normally with preview mode enabled
		// then maybe after a delay of no typing, call it with preview off,
		// to generate any new videos
		// or don't use preview at all! maybe it's fine!

		init(function() {
			if (c == "\n" || !c)
				lineStart();
			else if (c != " ")
				startOfLine = false;
			else if (startOfLine)
				leadingSpaces++;
			i++;
			c = code.charAt(i);
		}, options, codeInput);
		
		var tags = {
			spoiler: "spoiler",
			align: "align",
			sub: "subscript",
			sup: "superscript",
			anchor: "anchor",
		};
		
		while (c) {
			if (eatChar("\n")) {
				endLine();
				//==========
				// \ escape
			} else if (eatChar("\\")) {
				if (c == "\n")
					addLineBreak();
				else
					addText(c);
				scan();
				//===============
				// { group start (why did I call these "groups"?)
			} else if (c == "{") {
				readEnv();
				//=============
				// } group end
			} else if (eatChar("}")) {
				if (stackContains(null)) {
					closeAll(false);
				} else {
					addText("}");
				}
				//================
				// * heading/bold
			} else if (c == "*") {
				if (startOfLine && (code[i+1] == "*" || code[i+1] == " ")) {
					var headingLevel = 0;
					while (eatChar("*"))
						headingLevel++;
					if (headingLevel > 3)
						headingLevel = 3;
					
					if (eatChar(" "))
						startBlock('heading', {}, headingLevel);
					else
						addMulti('*', headingLevel);
				} else {
					doMarkup('bold', options.bold);
				}
			} else if (c == "/") {
				doMarkup('italic', options.italic);
			} else if (c == "_") {
				doMarkup('underline', options.underline);
			} else if (c == "~") {
				doMarkup('strikethrough', options.strikethrough);
				//============
				// >... quote
			} else if (startOfLine && eatChar(">")) {
				// todo: maybe >text should be a quote without author... 
				// need to add a way to add information to quotes:
				// - user ID
				// - post ID
				start = i;
				while (eatChar(" "))
					;
				while (c && !char_in(c, " \n{:"))
					scan();
				var name = code.substring(start, i).trim();
				eatChar(":");
				while (eatChar(" "))
					;
				startBlock('quote', {}, {"":name});
				//==============
				// -... list/hr
			} else if (startOfLine && eatChar("-")) {
				textBuffer = ""; //hack:
				//----------
				// --... hr
				if (eatChar("-")) {
					var count = 2;
					while (eatChar("-"))
						count++;
					//-------------
					// ---<EOL> hr
					if (c == "\n" || !c) { //this is kind of bad
						addBlock(options.line());
						skipNextLineBreak = true; //hack
						//----------
						// ---... normal text
					} else {
						addMulti("-", count);
					}
					//------------
					// - ... list
				} else if (eatChar(" ")) {
					startBlock('list', {level:leadingSpaces}, {});
					startBlock('item', {level:leadingSpaces});
					//---------------
					// - normal char
				} else
					addText("-");
				//==========================
				// ] end link if inside one
			} else if (c == "]" && stack.top().inBrackets){ //this might break if it assumes .top() exists. needs more testing
				scan();
				if (stack.top().big) {
					if (eatChar("]"))
						endBlock();
					else
						addText("]");
				} else
					endBlock();
				//============
				// |... table
			} else if (c == "|") {
				var top = stack.top();
				// continuation
				if (top.type == 'cell') {
					scan();
					var row = top.row;
					var table = top.row.table;
					var eaten = eatChar("\n");
					//--------------
					// | | next row
					if (eaten && eatChar("|")) {
						// number of cells in first row
						// determines number of columns in table
						if (table.columns == null)
							table.columns = row.cells;
						// end blocks
						endBlock(); //cell
						if (top_is('row')) //always
							endBlock();
						// start row
						// calculate number of cells in row which will be
						// already filled due to previous row-spanning cells
						var cells = 0
						table.rowspans = table.rowspans.map(function(span){
							cells++;
							return span-1;
						}).filter(function(span){return span > 0});
						var row = startBlock('row', {table:table, cells:cells});
						row.header = eatChar("*");
						// start cell
						startCell(row);
						//--------------------------
						// | next cell or table end
					} else {
						row.cells++;
						textBuffer = textBuffer.replace(/ *$/,""); //strip trailing spaces (TODO: allow \<space>)
						// end of table
						// table ends when number of cells in current row = number of cells in first row
						// single-row tables are not easily possible ..
						// TODO: fix single row tables
						if (table.columns != null && row.cells > table.columns) {
							endBlock(); //end cell
							if (top_is('row')) //always
								endBlock(); //row
							if (top_is('table')) //always
								endBlock(); //table
							if (eaten)
								addLineBreak();
						} else { // next cell
							endBlock(); //cell
							startCell(row);
						}
					}
					// start of new table (must be at beginning of line)
				} else if (startOfLine) {
					scan();
					table = startBlock('table', {
						columns: null,
						rowspans: []
					}, {});
					row = startBlock('row', {
						table: table,
						cells: 0
					});
					row.header = eatChar("*");
					startCell(row);
				} else {
					scan();
					addText("|");
				}
				//===========
				// `... code
			} else if (eatChar("`")) {
				//---------------
				// ``...
				if (eatChar("`")) {
					//----------------
					// ``` code block
					if (eatChar("`")) {
						// read lang name
						start = i;
						while (c && c!="\n" && c!="`")
							scan();
						//todo: protect against ```why won't this work``` ?
						var language = code.substring(start, i).trim().toLowerCase();
						var eaten = eatChar("\n");
						start = i;
						i = code.indexOf("```", i);
						addBlock(options.code(
							{"": language},
							code.substring(start, i!=-1 ? i : code.length)
						));
						skipNextLineBreak = eaten;
						if (i != -1) {
							restore(i + 3);
						} else {
							restore(code.length);
						}
						//------------
						// `` invalid
					} else {
						addText("``");
					}
					// --------------
					// ` inline code
				} else {
					start = i;
					var codeText = ""
					while (c) {
						if (c=="`") {
							if (code[i+1] == "`") {
								if (i == start+1 && codeText[0] == " ")
									codeText = codeText.substr(1);
								scan();
							} else
								break;
						}
						codeText += c;
						scan();
					}
					addBlock(options.icode({},codeText));
					scan();
				}
				//
				//================
				// link
			} else if (readLink()) {
				//
				//=============
				// normal char
			} else {
				addText(c);
				scan();
			}
		}
		// END
		endAll();
		return output.node;
		
		
		// ###################################
		
		function readBracketedLink(embed) {
			if (eatChar("[")) {
				if (eatChar("[")) {
					// read url:
					var start = i;
					var part2 = false;
					var url = readUrl(true);
					if (eatChar("]")) {
						if (eatChar("]"))
							;
						else if (eatChar("["))
							part2 = true;
					}
					startBlock(embed ? urlType(url) : 'link', {big: true}, {"":url}, preview);
					if (part2)
						stack.top().inBrackets = true;
					else {
						addText(url);
						endBlock();
					}
					return true;
				} else {
					addText("[");
				}
			}
			return false;
		}
		
		function readEnv() {
			if (!eatChar("{"))
				return false;
			startBlock(null, {});
			lineStart();
			
			var start = i;
			if (eatChar("#")){
				var name = readTagName();
				var props = readProps();
				// todo: make this better lol
				var func = tags[name];
				if (func && !(name=="spoiler" && stackContains("spoiler"))) {
					startBlock(func, {}, props);
				} else {
					addBlock(options.invalid(code.substring(start, i), "invalid tag"))
				}
				/*if (displayBlock({type:name}))
				  skipNextLineBreak = true; //what does this even do?*/
			}
			lineStart();
			//	eatChar("\n");
			return true;
		}
		
		// read table cell properties and start cell block, and eat whitespace
		// assumed to be called when pointing to char after |
		function startCell(row) {
			var props = {}
			if (eatChar("#"))
				Object.assign(props, readProps());
			
			if (props.rs)
				row.table.rowspans.push(props.rs-1);
			if (props.cs)
				row.cells += props.cs-1;
			
			if (row.header)
				props.h = true;
			
			startBlock('cell', {row: row}, props);
			while (eatChar(" "))
				;
		}

		// split string on first occurance
		function split1(string, sep) {
			var n = string.indexOf(sep);
			if (n == -1)
				return [string, null];
			else
				return [string.substr(0,n), string.substr(n+sep.length)];
		}
		
		function readTagName() {
			var start = i;
			while (c>="a" && c<="z") {
				scan();
			}
			if (i > start)
				return code.substring(start, i);
		}
		
		// read properties key=value,key=value... ended by a space or \n or } or {
		// =value is optional and defaults to `true`
		function readProps() {
			var start = i;
			var end = code.indexOf(" ", i);
			if (end < 0)
				end = code.length;
			var end2 = code.indexOf("\n", i);
			if (end2 >= 0 && end2 < end)
				end = end2;
			end2 = code.indexOf("}", i);
			if (end2 >= 0 && end2 < end)
				end = end2;
			end2 = code.indexOf("{", i);
			if (end2 >= 0 && end2 < end)
				end = end2;


			restore(end);
			eatChar(" ");

			var propst = code.substring(start, end);
			var props = {};
			propst.split(",").forEach(function(x){
				var pair = split1(x, "=");
				if (pair[1] == null)
					pair[1] = true;
				props[pair[0]] = pair[1];
			});
			return props;
		}

		// string.repeat doesn't exist
		function addMulti(text, count) {
			while (count --> 0)
				addText(text);
		}

		function readLink() {
			var embed = eatChar("!");
			if (readBracketedLink(embed) || readPlainLink(embed))
				return true;
			else if (embed) {
				addText("!");
				return true;
				//lesson: if anything is eaten, you must return true if it's in the top level if switch block
			}
		}

		function readPlainLink(embed) {
			if (isUrlStart()) {
				var url = readUrl();
				var after = eatChar("[");
				startBlock(embed ? urlType(url) : 'link', {
					inBrackets: after
				}, {"":url}, preview);
				if (!after) {
					addText(url);
					endBlock();
				}
				return true;
			}
		}
		
		// closeAll(true) - called at end of document
		// closeAll(false) - called at end of {} block
		function closeAll(force) {
			while(stack.length) {
				var top = stack.top();
				if (top.type == 'root') {
					break;
				}
				if (!force && top.type == null) {
					endBlock();
					break;
				}
				endBlock();
			}
		}

		// called at the end of a line (unescaped newline)
		function endLine() {
			while (1) {
				var top = stack.top();
				if (top.type == 'heading' || top.type == 'quote') {
					endBlock();
				} else if (top.type == 'item') {
					if (top.type == 'item')
						endBlock();
					var indent = 0;
					while (eatChar(" "))
						indent++;
					// OPTION 1:
					// no next item; end list
					if (c != "-") {
						while (top_is('list')) //should ALWAYS happen at least once
							endBlock();
						addMulti(" ", indent);
					} else {
						scan();
						while (eatChar(" ")) {}
						// OPTION 2:
						// next item has same indent level; add item to list
						if (indent == top.level) {
							startBlock('item', {level: indent});
							// OPTION 3:
							// next item has larger indent; start nested list	
						} else if (indent > top.level) {
							startBlock('list', {level: indent}, {});
							startBlock('item', {level: indent}); // then made the first item of the new list
							// OPTION 4:
							// next item has less indent; try to exist 1 or more layers of nested lists
							// if this fails, fall back to just creating a new item in the current list
						} else {
							// TODO: currently this will just fail completely 
							while(1) {
								top = stack.top();
								if (top && top.type == 'list') {
									if (top.level <= indent) {
										break;
									} else {
										endBlock();
									}
								} else {
									// no suitable list was found :(
									// so just create a new one
									startBlock('list', {level: indent}, {});
									break;
								}
							}
							startBlock('item', {level: indent});
						}
						break; //really?
					}
				} else {
					addLineBreak();
					break;
				}
			}
		}

		// audio, video, image, youtube
		//todo: improve this lol
		function urlType(url) {
			if (/(\.mp3(?!\w)|\.ogg(?!\w)|\.wav(?!\w)|#audio$)/.test(url))
				return "audio";
			if (/(\.mp4(?!\w)|\.mkv(?!\w)|#video$)/.test(url))
				return "video";
			if (/(?:https?:\/\/)?(?:www\.)?youtu\.?be(?:\.com)?\/?.*(?:watch|embed)?(?:.*v=|v\/|\/)([\w\-_]+)\&?/.test(url))
				return "youtube";
			return "image";
		}

		// common code for all text styling tags (bold etc.)
		function doMarkup(type, create) {
			var symbol = c;
			scan();
			if (canStartMarkup(type)) {
				startBlock(type, {});
			} else if (canEndMarkup(type)) {
				endBlock();
			} else {
				addText(symbol);
			}
		}
		// todo: maybe have support for non-ASCII punctuation/whitespace?
		function canStartMarkup(type) {
			return (
				(!code[i-2] || char_in(code[i-2], " \t\n({'\"")) && //prev char is one of these (or start of text)
				!char_in(c, " \t\n,'\"") && //next char is not one of these
				!stackContains(type)
			);
		}
		function canEndMarkup(type) {
			return (
				top_is(type) && //there is an item to close
				!char_in(code[i-2], " \t\n,'\"") && //prev char is not one of these
				(!c || char_in(c, " \t\n-.,:!?')}\"")) //next char is one of these (or end of text)
			);
		}
		function char_in(chr, list) {
			return chr && list.indexOf(chr) != -1;
		}

		function lineStart() {
			startOfLine = true;
			leadingSpaces = 0;
		}
		
	}

	Parse.lang.bbcode = function(codeArg, preview) {
		var noNesting = {
			spoiler:true
		};
		var blocks = {
			b: options.bold,
			i: options.italic,
			u: options.underline,
			s: options.strikethrough,
			sup: options.superscript,
			sub: options.subscript,
			h1: function(){return options.heading(1)},
			h2: function(){return options.heading(2)},
			h3: function(){return options.heading(3)},
			table: options.table,
			tr: options.row,
			td: options.cell,
			th: function(arg, opt){
				return options.cell(Object.assign({h:true}, opt))
			},
			code: true, 
			align: options.align,
			url: options.link,//+<VERY special case> (only hardcode when no argument)
			youtube: true, //<special case>,
			audio: true,
			video: true,
			img: true, //<special case>,
			list: options.list,
			spoiler: options.spoiler,
			quote: options.quote,
			anchor: options.anchor,
			item: options.item,
		};
		init(function() {
			i++;
			c = code.charAt(i);
		}, blocks, codeArg);
		
		var specialBlock = {
			url: function(args, contents){
				var node = options.link({"":contents});
				options.append(node, options.text(contents));
				return node;
			},
			code: function(args, contents) {
				var inline = args[""] == 'inline';
				args[""] = args.lang;
				if (inline)
					return options.icode(args, contents);
				
				if (contents[0]=="\n")
					contents = contents.substr(1);
				return options.code(args, contents);
			},
			youtube: function(args, contents) {
				return options.youtube({"":contents}, preview);
			},
			img: function(args, contents) {
				return options.image({"":contents});
			},
			audio: function(args, contents) {
				return options.audio({"":contents});
			},
			video: function(args, contents) {
				return options.video({"":contents});
			}
		};

		var point = 0;
		
		while (c) {
			//===========
			// [... tag?
			if (eatChar("[")) {
				point = i-1;
				// [/... end tag?
				if(eatChar("/")) {
					var name = readTagName();
					// invalid end tag
					if (!eatChar("]") || !name) {
						cancel();
					// valid end tag
					} else {
						// end last item in lists
						if (name == "list" && stack.top().type == "item")
							endBlock(point);
						if (name == stack.top().type) {
							endBlock(point);
							// eat whitespace between table cells
							if (name == 'td' || name == 'th' || name == 'tr') {
								while(eatChar(' ')||eatChar('\n')){
								}
							}
						} else {
							addBlock(options.invalid(code.substring(point, i), "unexpected closing tag"));
						}
					}
				// [... start tag?
				} else {
					var name = readTagName();
					if (!name || !blocks[name]) {
						// special case [*] list item
						if (eatChar("*") && eatChar("]")) {
							if (stack.top().type == "item")
								endBlock(point);
							var top = stack.top()
							if (top.type == "list") {
								startBlock("item", {}, {});
							}
							else
								cancel();
						} else {
							cancel();
						}
					} else {
						// [tag=...
						var arg = true, args = {};
						if (eatChar("=")) {
							var start=i;
							if (eatChar('"')) {
								start++;
								while (c && c!='"')
									scan();
								if (c == '"') {
									arg = code.substring(start, i-1);
									scan();
								}
							} else {
								while (c && c!="]" && c!=" ")
									scan();
								if (c == "]" || c == " ")
									arg = code.substring(start, i);
							}
						}
						if (eatChar(" ")) {
							args = readArgList() || {};
						}
						if (arg!=true)
							args[""] = arg;
						if (eatChar("]")) {
							if (specialBlock[name] && !(name == "url" && arg!=true)) {
								var endTag = "[/"+name+"]";
								var end = code.indexOf(endTag, i);
								if (end < 0)
									cancel();
								else {
									var contents = code.substring(i, end);
									restore(end + endTag.length);
									
									// todo: this can't handle args with caching currently
									var node = tryGetCached(cache, name, contents, function() {
										return specialBlock[name](args, contents);
									});
									addBlock(node);
									
									if (node.block)
										skipNextLineBreak = true;
								}
							} else if (name!="item" && blocks[name] && !(noNesting[name] && stackContains(name))) {
								if (name == 'tr' || name == 'table') {
									while(eatChar(' ')||eatChar('\n')){
									}
								}
								startBlock(name, {}, args);
							} else
								addBlock(options.invalid(code.substring(point, i), "invalid tag"));
						} else {
							cancel();
						}
					}
				}
			} else if (readPlainLink()) {
			} else if (eatChar('\n')) {
				addLineBreak();
			} else {
				addText(c);
				scan();
			}
		}
		endAll();
		return output.node;
		
		function cancel() {
			restore(point);
			addText(c);
			scan();
		}

		function readPlainLink() {
			if (isUrlStart()) {
				var url = readUrl();
				addBlock(specialBlock.url({},url));
				return true;
			}
		}

		function readArgList() {
			var args = {};
			while (1) {
				// read key
				var start = i;
				while (isTagChar(c))
					scan();
				var key = code.substring(start, i);
				// key=...
				if (eatChar("=")) {
					// key="...
					if (eatChar('"')) {
						start = i;
						while (c && c!='"' && c!="\n")
							scan();
						if (eatChar('"'))
							args[key] = code.substring(start, i-2);
						else
							return null;
						// key=...
					} else {
						start = i;
						while (c && c!=" " && c!="]" && c!="\n")
							scan();
						if (c == "]") {
							args[key] = code.substring(start, i);
							return args;
						} else if (eatChar(" "))
							args[key] = code.substring(start, i-1);
						else
							return null;
					}
					// key ...
				} else if (eatChar(" ")) {
					args[key] = true;
					// key]...
				} else if (c == "]") {
					args[key] = true;
					return args;
					// key<other char> (error)
				} else
					return null;
			}
		}
		
		function readTagName() {
			var start = i;
			while (isTagChar(c))
				scan();
			return code.substring(start, i);
		}

		function isTagChar(c) {
			return c>="a" && c<="z" || c>="A"&&c<="Z" || c>="0"&&c<="9";
		}
	}
	
	// "plain text" (with autolinker)
	Parse.fallback = function(text) {
		var options = Parse.options;
		var root = options.root();
		i = 0;
		code = text;
		output = root;
		
		var linkRegex = /\b(?:https?:\/\/|sbs:)[-\w\$\.+!*'(),;/\?:@=&#%]*/g;
		var result;
		var out = "", last = 0;
		while (result = linkRegex.exec(text)) {
			// text before link
			options.append(root, options.text(text.substr(last, result.index)));
			// generate link
			var link = options.link({"": result[0]});
			options.append(link, options.text(result[0]));
			options.append(root, link);
			
			last = result.index + result[0].length;
		}
		// text after last link (or entire message if no links were found)
		options.append(root, options.text(text.substr(last)));
		
		return root.node;
	}
	
	Parse.parseLang = function(text, lang) {
		i=0;
		code = text;
		try {
			var parser = Parse.lang[lang] || Parse.fallback;
			return parser(text);
		} catch(e) {
			try {
				options.append(output, options.error(e,e.stack));
				options.append(output, options.text(code.substr(i)));
				return output.node
			} catch (e) {
				alert("Unrecoverable parser error! please report this!\n"+e);
			}
		}
	}
})();
//todo: make href-setting function
// which processes links automatically
// to add trailing # to fragment links
// OR some other way to solve the issue of
// fragment links not working when clicked again

function renderKeyInfo(key, data, element) {
	element = element || document.createElement('span');
	element.innerHTML = "";
	
	var icon = document.createElement('img');
	icon.src = protocol()+"//sbapi.me/get/"+data.path+"/META/icon";
	icon.className = "metaIcon";

	element.appendChild(icon);
	
	element.appendChild(textItem(data.filename, "pre metaTitle"));
	
	element.appendChild(textItem(data.author.name, "pre metaAuthor")); //todo: link with sbs account somehow?
	return element;
}

function renderSidebarItem(page, user, comment) {
	if (!page) {
		page = {};
	}
	var d = document.createElement('a');
	d.href = "#pages/"+page.id+"#comment-"+comment.id;
	d.className = "pre";
	d.textContent = page.name+"\n"+user.username+": "+comment.content;
	return d;
}

function renderContentName(name, icon) {
	var span = document.createElement('span');
	span.className = "textItem pageName";
	if (icon) {
		var img = document.createElement('span');
		img.setAttribute('role', 'img');
		img.setAttribute('aria-label', icon);
		img.className = "item iconBg iconBg-"+icon;
		span.appendChild(img);
	}
	span.appendChild(textItem(name, 'pre'));
	return span;
}

function renderPath(element, list) {
	element.innerHTML = "";
	if (!list)
		return;
	list.forEach(function(item, i, list) {
		if (item) {
			var link = document.createElement('a');
			link.href = item[0];
			link.textContent = item[1];
			link.className = "textItem pre";
			element.appendChild(link);
		}
		
		if (i < list.length-1) {
			var slash = document.createElement('span');
			slash.textContent = "/";
			slash.className = "pathSeparator textItem";
			element.appendChild(slash);
		}
	});
}

function userAvatar(user, cls, big) {
	if (cls.innerHTML != undefined)
		var img = cls
	else {
		img = document.createElement('img');
		img.className = cls+" avatar";
	}
	if (big)
		img.src = user.bigAvatarURL;
	else
		img.src = user.avatarURL;
	img.alt = "";
	return img;
}

function textItem(text, cls) {
	var s = document.createElement('span');
	s.textContent = text;
	s.className = 'textItem';
	if (cls)
		s.className += " "+cls;
	return s;
}

// todo: this should probably be like
// <a><figure><img><figcaption>
function renderUserLink(user, nameFirst) {
	var a = document.createElement('a');
	a.className = 'textItem userLink ib';
	if (user) {
		a.href = "#user/"+user.id;
		var name = textItem(user.username);
		name.className = "username textItem pre"
		var avatar = userAvatar(user, 'item');
		if (nameFirst)
			a.appendChild(name)
		a.appendChild(avatar)
		if (!nameFirst)
			a.appendChild(name)
	} else {
		a.textContent = "MISSINGNO. "
	}
	return a;
}

function renderTimeAgo(date) {
	var time = document.createElement('time');
	var d = parseDate(date)
	time.setAttribute('datetime',date);
	time.setAttribute('title',readableDate(d));
	time.textContent = timeAgo(d);
	time.className = "textItem time";
	return time;
}

function renderAuthorBox(page, users, element) {
	element.innerHTML = "";
	if (!page)
		return;
	element.appendChild(textItem("Author:"));
	element.appendChild(document.createTextNode(" "));
	element.appendChild(renderUserLink(users[page.createUserId], true));
	element.appendChild(renderTimeAgo(page.createDate));
	// page was edited by other user
	if (page.editUserId != page.createUserId) {
		element.appendChild(textItem(", edited by: "));
		var editedText = true;
		element.appendChild(renderUserLink(users[page.editUserId], true));
	}
	// page was edited
	if (page.createDate != page.editDate) {
		if (!editedText)
			element.appendChild(textItem(", edited "));
		element.appendChild(renderTimeAgo(page.editDate));
	}
}

// Page in the list displayed on a category view
function renderCategoryPage(page, users, pinned) {
	var div = document.createElement('a');
	div.href = "#pages/"+page.id;
	div.className = "pre categoryPage bar rem2-3";

	var icon = "page";
	if (pinned)
		icon = "pin";
	if (!hasPerm(page.permissions, 0, 'r'))
		icon = "hiddenpage";
	div.appendChild(renderContentName(page.name, icon));

	var user = users[page.createUserId];
	if (user) {
		var right = renderUserLink(user, true);
		right.className += ' rightAlign';
		div.appendChild(right);
	}
	return div;
}

// HH:MM AM/PM
function timeString(date) {
	if (new Date()-date > 1000*60*60*12) {
		var options = {year:'numeric',month:'long',day:'numeric',hour:'2-digit', minute:'2-digit'}
	} else {
		options = {hour:'2-digit', minute:'2-digit'}
	}
	return date.toLocaleString([], options);
}

function renderSystemMessage(text) {
	var node = document.createElement('div');
	node.className = 'message systemMessage';
	node.textContent = text;
	return node;
}

function renderUserListAvatar(user) {
	var a = document.createElement('a');
	a.appendChild(userAvatar(user,""));
	a.title = user.username;
	a.className = "item";
	a.href = "#user/"+user.id;
	return a;
}

// chat message block
function renderUserBlock(user, date) {
	var div = document.createElement('div');
	div.className = 'message';

	var time = document.createElement('span');
	time.textContent = timeString(date);
	time.className = 'messageTime'
	div.appendChild(time);

	div.appendChild(userAvatar(user, 'avatar'));

	var name = document.createElement('span');
	name.className = 'username';
	name.textContent = user.username+":";
	div.appendChild(name);
	
	var contentBox = document.createElement('div');
	contentBox.className = 'messageContents';
	div.appendChild(contentBox);
	return [div, contentBox];
}

function renderCategory(cat, users) {
	var div = document.createElement('a');
	div.href = "#categories/"+cat.id;
	div.className = "pre categoryPage rem2-3 bar";

	var title = renderContentName(cat.name, "category");
	
	div.appendChild(title);
	return div;
}

function readableDate(date) {
	return date.toLocaleString();
}

function timeAgo(date) {
	var seconds = Math.floor((new Date() - date) / 1000);
	var interval = Math.floor(seconds / 31536000);
	if (interval >= 1) return interval + " years ago";
	interval = Math.round(seconds / 2592000);
	if (interval >= 1) return interval + " months ago";
	interval = Math.round(seconds / 86400);
	if (interval >= 1) return interval + " days ago";
	interval = Math.round(seconds / 3600);
	if (interval >= 1) return interval + " hours ago";
	interval = Math.round(seconds / 60);
	if (interval >= 1) return interval + " minutes ago";
	if (seconds < 0)
		return " IN THE FUTURE?";
	return Math.round(seconds) + " seconds ago";
}

function renderPageContents(page, element, cache) {
	if (page.values) {
		var lang = page.values.markupLang;
	}
	var out = Parse.parseLang(page.content, lang);
	if (element)
		setChild(element, out);
	
	return out
}

// as far as I know, the o3DS doesn't support parsing ISO 8601 timestamps
function parseDate(str) {
	var data = str.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:.\d+)?)/);
	if (data) {
		var sec = Math.floor(+data[6]);
		var ms = +data[6] - sec;
		return new Date(Date.UTC(+data[1], +data[2]-1, +data[3], +data[4], +data[5], sec, ms));
	}
	return new Date(0);
}

function renderActivityItem(activity, page, user, noTime) {
	if (!user)
		user = [];
	else if (!(user instanceof Array))
		user = [user];

	switch(activity.action) {
	case "c":
		var text = "created";
		break;case "u":
		text = "edited";
		break;case "d":
		text = "deleted";
		break;case "p":
		text = "posted on";
		break;default:
		text = "unknown action";
	}
	var div = document.createElement('a');
	div.className = "listItem bar rem1-7";
	var action = document.createElement('span');
	action.className = "textItem noColor";
	action.textContent = text+" ";

	if (activity.type == 'content') {
		if (activity.action == "p")
			div.href = "#pages/"+activity.contentId+"#comment-"+activity.id; //todo: comment link
		else
			div.href = "#pages/"+activity.contentId;

		var icon = "page";
		if (!hasPerm(page.permissions, 0, 'r'))
			icon = "hiddenpage";
		var name = renderContentName(page.name, icon)
	} else if (activity.type == 'category') {
		div.href = "#categories/"+activity.contentId;
		var name = renderContentName(page.name, 'category')
	}
	
	user.forEach(function(user){
		var usr = renderUserLink(user);
		div.appendChild(usr);
		div.appendChild(document.createTextNode(" "));
	});
	div.appendChild(action);
	div.appendChild(name);
	if (!noTime) {
		var time = renderTimeAgo(activity.date);
		time.className += " rightAlign";
		div.appendChild(time);
	}
	return div;
}

function renderMemberListUser(user) {
	var div = renderUserLink(user)
	div.className = "member userLink rem2-3";
	return div;
}

function renderMessageGap() {
	var div = document.createElement('div');
	div.className = "messageGap";
	return div;
}

function renderMessagePart(comment, sizedOnload){
	var content = comment.content;
	var text, markup;
	if (content[0] == "{") {
		var j = parseJSON(content);
		if (j) {
			text = j.t;
			markup = j.m;
		} else
			text = content;
	} else {
		var i = content.indexOf("\n");
		if (i<0)
			text = content;
		else
			text = content.substr(i+1);
	}
	element = parser(markup)(text);
	element.className += ' messagePart';
	element.id = "_anchor_comment-"+comment.id;
	//document.title=comment.username+":"+text;
	return element;
}

function parser(markup) {
	return Parse.lang[markup] || Parse.fallback;
}

// Based on sbs chat autoscroller
function AutoScroller(element) {
	this.element = element;
	this.smoothScroll = true;
	this.nodes = {};
	this.blocks = {};
	var $=this;
	function onresize() {
		//todo: make this only happen when the element was previously scrolled to bottom
		// may need to detect onscroll to keep track
		// I'd like to avoid onscroll for o3ds though (especially since window can't even be resized so it doesn't matter) (also does o3DS EVEN HAVE onscroll lol)
		$.autoScroll(true);
	};
	//window.addEventListener('resize', onresize); //todo: only do this whe nin chat mode!!
}
// do autoscroll
AutoScroller.prototype.autoScroll = function(instant) {
	var parent = this.element.parentNode;
	if (!window.requestAnimationFrame || !this.smoothScroll || instant) {
		parent.scrollTop = parent.scrollHeight - parent.clientHeight;
	} else {
		// only start a new animation if previous isn't already running
		if (!this.animationId) {
			this.autoScrollAnimation();
		}
	}
}
// check if element is scrolled to near the bottom (within 0.25*height)
// this threshold can probably be decreased...
AutoScroller.prototype.shouldScroll = function() {
	return this.scrollDistance() < this.element.parentNode.clientHeight*0.25;
}
// check distance to bottom
AutoScroller.prototype.scrollDistance = function() {
	var parent = this.element.parentNode;
	return parent.scrollHeight-parent.clientHeight-parent.scrollTop;
}

// scrolls down until reaching bottom
// stops if interrupted by user scrolling
AutoScroller.prototype.autoScrollAnimation = function() {
	var $=this;
	var parent = this.element.parentNode;

	parent.scrollTop += Math.max(Math.ceil(this.scrollDistance()/4), 1);
	
	if (this.scrollDistance() > 0) {
		// save scroll position
		this.expectedTop = parent.scrollTop;
		this.animationId = window.requestAnimationFrame(function(time) {
			// only call again if scroll pos has not changed
			// (if it has, that means the user probably scrolled manually)
			if ($.expectedTop == $.element.parentNode.scrollTop) {
				$.autoScrollAnimation();
			} else {
				$.animationId = null;
			}
		});
	} else {
		this.animationId = null;
	}
}
AutoScroller.prototype.insert = function(id, node, uid, makeBlock) {
	var s = this.shouldScroll();
	if (id == null) {
		this.element.appendChild(node);
		this.lastUid = undefined;
		this.lastUidBlock = undefined;
	} else {
		// replace an existing message (we assume uid doesn't change)
		if (this.nodes[id]) {
			this.nodes[id].parentNode.replaceChild(node, this.nodes[id]);
			// insert a new line to the last block
		} else if (uid && this.lastUid == uid) {
			this.lastUidBlock.appendChild(node);
			// create a new block
		} else {
			var b = makeBlock();
			b[1].appendChild(node);
			this.element.appendChild(b[0]);
			
			this.lastUidBlock = b[1];
			this.lastUid = uid;
		}
		this.nodes[id] = node;
	}
	if (s)
		this.autoScroll();
}
AutoScroller.prototype.remove = function(id) {
	var node = this.nodes[id]
	// todo: remove block when all messages are gone from it
	// don't forget to update lastUidBlock etc. too
	if (node) {
		node.parentNode.removeChild(node);
	}
	this.nodes[id] = undefined;
}
// currently just clears no matter what
// in the future you might, if this is properly connected to a LongPoller,
// cache messages when switching rooms, or something
AutoScroller.prototype.switchRoom = function(id) {
	this.element.innerHTML = "";
	this.lastUid = undefined;
	this.lastUidBlock = undefined;
	this.nodes = {};
	// probably needs more cleanup
}

AutoScroller.prototype.embed = function(node) {
	var s = this.shouldScroll();
	this.element.appendChild(node);
	this.lastUid = null;
	this.lastUidBlock = null;
	if (s)
		this.autoScroll();
}
// this file contains code for rendering stuff direclty to the screen
// none of it is "reusable" etc.

// clean up stuff whenever switching pages
function cleanUp(type) {
	flag('myUserPage');
	flag('canEdit');
	flag('page');
	$messageList.innerHTML = "";
	$authorBox.innerHTML = "";
	$sbapiInfo.innerHTML = "";
	$fileBox.innerHTML = "";
	$fileView.src = "";
	var nodes = document.querySelectorAll(".markup-root");
	for (var i=0;i<nodes.length;i++) {
		nodes[i].innerHTML = "";
	}
}

var currentChatRoom;

function setTitle(text, icon) {
	$pageTitle.textContent = text;
	document.title = text;
	if (icon) {
		$pageTitleIcon.className = "item iconBg iconBg-"+icon;
	} else {
		$pageTitleIcon.className = "";
	}
}

function submitUserSettings() {
	me.setSensitive({
		oldPassword: $settingsOldPassword.value,
		username: $settingsUsername.value || undefined,
		newPassword: $settingsNewPassword.value || undefined,
		newEmail: $settingsEmail.value || undefined
	}, function(){});
}

var editingPage;
var editorCache = {};

function cleanUpEditor() {
	$editorTextarea.value = "";
}

function newPage(query) {
	return {
		parentId: +query.cid || 0,
		type: query.type || "@page.resource",
		name: query.name || "",
		values: {
			markupLang: "12y"
		},
		permissions: {
			0: "cr"
		},
		keywords: []
	};
}

function fillEditorFields(page) {
	$titleInput.value = page.name || "";
	if (page.values)
		var markup = page.values.markupLang;
	if (!markup)
		markup = "12y";
	$markupSelect.value = markup;
	if (page.content)
		$editorTextarea.value = page.content;
	updateEditorPreview();
	$keywords.value = page.keywords.join(" ");
	$permissions.value = JSON.stringify(page.permissions);
	$editPageType.value = page.type;
	$editPageCategory.value = page.parentId;
	
	generatePagePath(page, me.userCache); //usercache is hack lol
}

function readEditorFields(page) {
	page.name = $titleInput.value;
	page.values.markupLang = $markupSelect.value;
	page.keywords = $keywords.value.split(" ");
	page.permissions = JSON.parse($permissions.value);
	page.type = $editPageType.value;
	page.content = $editorTextarea.value;
	page.parentId = +$editPageCategory.value;
}

function newCategory(query) {
	return {
		parentId: +query.cid || 0,
		name: "untitled",
		values: {},
		permissions: {
			0: "cr"
		},
		description: ""
	};
}

function fillCateditFields(cat) {
	$cateditTitle.value = cat.name;
	var pinned = cat.values.pinned || "";
	$cateditPinned.value = pinned;
	$cateditCategory.value = cat.parentId;
	$cateditPermissions.value = JSON.stringify(cat.permissions);
	$cateditDescription.value = cat.description;
	generatePath(makeCategoryPath(me.categoryTree, cat.id));
}

function readCateditFields(cat) {
	cat.name = $cateditTitle.value;
	cat.values.pinned = $cateditPinned.value;
	cat.parentId = +$cateditCategory.value;
	cat.permissions = parseJSON($cateditPermissions.value);
	cat.description = $cateditDescription.value;
}

var editingCategory;

function attr(element, attr, value) {
	if (value == undefined)
		element.removeAttribute(attr)
	else
		element.setAttribute(attr, value);
}

function generatePagePath(page, users) {
	// user page (at root)
	if (page.type == "@user.page" && !page.parentId) {
		var creator = users[page.createUserId];
		generatePath([["#users","Users"], ["#user/"+creator.id, creator.username], ["#pages/"+page.id, page.name]]);
	} else if (page.id) {
		generatePath(makeCategoryPath(me.categoryTree, page.parentId, page));
	} else {
		generatePath(makeCategoryPath(me.categoryTree, page.parentId));
	}
}

function megaAggregate(activity, ca, contents) {
	var contentMap = {};
	contents.forEach(function(x){
		contentMap[x.id] = x;
	})
	var allAct = activity.concat(ca.map(function(x){
		if (x.createDate) {
			return {
				action: "p",
				contentId: x.parentId,
				date: x.createDate,
				id: x.id,
				userId: x.createUserId,
				type: 'content'
			}
		}
		return {
			action: "p",
			contentId: x.id,
			date: x.lastDate,
			firstDate: x.firstDate,
			id: x.lastId,
			userId: x.userIds,
			type: 'content',
		}
	}));
	allAct = allAct.filter(function(x) {
		if (x.action == 'd')
			x.content = {name: x.extra, id: x.contentId, deleted: true};
		else if (x.type == "content")
			x.content = contentMap[x.contentId];
		else if (x.type == "category" && me.categoryTree)
			x.content = me.categoryTree.map[x.contentId];
		else
			return; //some weird activity type
		return x;
	});
	allAct = allAct.sort(function(a, b) {
		if (a.date > b.date)
			return -1;
		if (a.date < b.date)
			return 1;
		return 0;
	});
	//todo: trim all trailing of same type because that's when the other runs out
	// also we can optimize merging of 2 sorted arrays here!
	return allAct;
}

function generatePath(path) {
	renderPath($navPane, path);
}
// function generatePagePath - category tree paths

function updateUserlist(listeners, userMap) {
	$chatUserlist.innerHTML = "";
	listeners && forDict(listeners, function(status, user) {
		if (status)
			$chatUserlist.appendChild(renderUserListAvatar(userMap[user]));
	})
}

function displayMessage(c, user) {
	if (c.deleted) {
		scroller.remove(c.id);
	} else {
		var node = renderMessagePart(c, function(){
			scroller.autoScroll();
		});
		scroller.insert(c.id, node, c.createUserId, function() {
			var b = renderUserBlock(user, parseDate(c.createDate));
			if (c.createUserId == me.uid)
				b[0].className += " ownMessage";
			return b;
		});
	}
}

function displayGap() {
	scroller.insert(null, renderMessageGap());
}

function handlePinned(pinned) {
	$categoryPinned.innerHTML = "";
	pinned.forEach(function(content) {
		$categoryPinned.appendChild(renderCategoryPage(content, users2, true));
	});
}

function sbapi(key, callback) {
	var x = new XMLHttpRequest();
	x.open('GET', protocol()+"//sbapi.me/get/"+key+"/info?json=1");
	x.onload = function() {
		var code = x.status;
		if (code == 200) {
			var resp = null;
			try {
				resp = JSON.parse(x.responseText);
			} catch(e) {
			}
			callback(resp);
		} else {
			callback(null);
		}
	}
	x.onerror = function() {
		callback(null);
	}
	x.setRequestHeader('Pragma', "no-cache"); // for internet explorer
	x.send();
}

function readFileFields(file) {
	file.name = $fileName.value;
	file.permissions = parseJSON($filePermissions.value);
	file.values = parseJSON($fileValues.value);
}

function fillFileFields(file) {
	$fileName.value = file.name;
	$filePermissions.value = JSON.stringify(file.permissions);
	$fileValues.value = JSON.stringify(file.values);
	console.log(me.userCache);
	$fileUser.textContent = me.userCache[file.createUserId].username;
}

function renderFileThumbnail(file) {
	var div = document.createElement('div');
	div.className = "fileThumbnail item";
	div.onclick = function() {
		selectFile(file);
	}
	var img = document.createElement('img');
	img.src = me.thumbnailURL(file.id);
	div.appendChild(img);
	return div;
}

function saveFileSettings() {
}

var selectedFile;
function selectFile(file) {
	selectedFile = null;
	fillFileFields(file);
	$fileView.src = me.imageURL(file.id);
	var doSelect = true;
	$fileView.onload = $fileView.onerror = function() {
		if (!doSelect)
			return;
		doSelect = false
		selectedFile = file;
		flag('fileSelected', true);
		flag('canEdit', /u/.test(file.myPerms));
	}
	flag('fileUploading');
}

function selectUploadedFile(file) {
	selectedFile = null;
	var url = URL.createObjectURL(file);
	URL.revokeObjectURL($fileView.src); //should probably only do this when it's actually a blob url lol
	$fileView.src = url;
	$fileView.onload = function() {
		selectedFile = file;
		flag('fileUploading', true);
	}
	flag('fileSelected');
}

function handleLoads(element) {
	var imgs = element.querySelectorAll('video, img, iframe');
	for (var i=0; i<imgs.length; i++) {
		imgs[i].onload = function() {
			scrollToAuto();
		}
	}
}

function doView(name, id, query, callback) {
	var view = views[name] || views.error;
	var cancelled;
	if (view.start) {
		var xhr = view.start(id, query, function() {
			if (cancelled)
				return;
			cleanUp(name);
			view.render.apply(null, arguments);
			callback();
		});
	} else {
		cleanUp(name);
		view.render(id, query, name);
		callback();
	}
	return function() {
		if (xhr && xhr.abort) {
			xhr.abort();
			loadEnd();
		}
		cancelled = true;
	}
}

var views = {
	files: {
		start: function(id, query, callback) {
			var page = +query.page || 0;
			selectedFile = null;
			flag('fileSelected');
			flag('fileUploading');
			return me.getFiles({}, page, function(files, users) {
				callback(files, page, users);
			});
		},
		render: function(files, page, users) {
			$main.className = "fileMode";
			setTitle("Files");
			$filePageNumber.textContent = " page "+page;
			$filePrev.href = "#files?page="+(page-1);
			$fileNext.href = "#files?page="+(page+1);
			generatePath([["#files","Files"], undefined]);
			if (files) {
				files.forEach(function(file) {
					$fileBox.appendChild(renderFileThumbnail(file));
				});
			}
		}
	},
	register: {
		render: function(id, query, callback) {
			$main.className = "registerMode";
			setTitle("Create an account");
		}
	},
	activity: {
		start: function(id, query, callback) {
			var page = +query.page || 0;
			return me.getActivity(page, function(activity, ca, pages, users) {
				callback(activity, ca, pages, users, page);
			});
		},
		render: function(activity, ca, pages, users, page) {
			$main.className = 'activityMode';
			$activityPageNumber.textContent = " "+page+" days ago";
			$activityPagePrev.href = "#activity?page="+(page-1);
			$activityPageNext.href = "#activity?page="+(page+1);
			generatePath([["#activity","Activity"], undefined]);
			if (activity) {
				setTitle("Activity");
				var last = {};
				$activity.innerHTML = "";
				
				megaAggregate(activity, ca, pages).forEach(function(activity){
					if (activity.contentId != last.contentId || activity.action != last.action || activity.userId != last.userId) {
						if (activity.content) {
							if (activity.userId instanceof Array)
								var user = activity.userId.map(function(x){
									return users[x];
								})
							else
								user = users[activity.userId]
							$activity.appendChild(renderActivityItem(activity, activity.content, user));
							last = activity;
						}
					}
				});
			}
		}
	},
	users: {
		start: function(id, query, callback) {
			var page = (+query.page-1) || 0;
			return me.getUsers({reverse: false}, page, function(users) {
				callback(users, page);
			});
		},
		render: function(users, page) {
			$main.className = 'membersMode';
			$memberList.innerHTML = "";
			$membersPrev.href = "#users?page="+Math.max(1,page);
			$membersNext.href = "#users?page="+(page+2);
			// we need better pagination :(
			generatePath([["#users","Users"],undefined]);
			setTitle("Users");
			users.forEach(function(user) {
				$memberList.appendChild(renderMemberListUser(user));
			});
		}
	},
	categories: {
		start: function(id, query, callback) {
			var page = +query.page || 0
			return me.getCategory(id, page, function(category, childs, contentz, users, pinned) {
				callback(category, childs, contentz, users, pinned, page, id);
			}, handlePinned);
		},
		render: function(category, childs, contentz, users, pinned, page, id) {
			//todo: make these only load the pages, not pinned etc. too;
			$categoryPageNumber.textContent = " "+page;
			$categoryPagesPrev.onclick = function() {
				window.location.hash = "#categories/"+id+"?page="+(page-1);
			}
			$categoryPagesNext.onclick = function() {
				window.location.hash = "#categories/"+id+"?page="+(page+1);
			}
			
			users2 = users;
			$main.className = 'categoryMode';
			$categoryPages.innerHTML = "";
			$categoryCategories.innerHTML = "";
			$categoryDescription.textContent = "";
			$categoryPinned.innerHTML = "";
			flag('canEdit', !!category);
			visible($categoryDescription, category && category.id);
			if (category) {
				$editButton.href = "#categories/edit/"+category.id;
				contentz.reverse();
				generatePath(makeCategoryPath(me.categoryTree, category.id));
				setTitle(category.name, 'category');
				if (category.id && category.description)
					renderPageContents({
						content: category.description,
						values: category.values
					}, $categoryDescription);
				childs.forEach(function(cat) {
					$categoryCategories.appendChild(renderCategory(cat, users));
				});
				$categoryPages.style.display="none";
				contentz.reverse();
				contentz.forEach(function(content) {
					$categoryPages.appendChild(renderCategoryPage(content, users));
				});
				$categoryPages.style.display="";
				$categoryCreatePage.href = "#pages/edit?cid="+category.id;
				if (pinned)
					handlePinned(pinned);
				else if (category.values.pinned) {
					category.values.pinned.split(",").forEach(function(x) {
						$categoryPinned.appendChild(renderCategoryPage({
							id: +x,
							name: ""
						}, users, true));
					});
				}
			} else {
				$categoryCreatePage.href = ""
				$main.className += "errorMode";
				setTitle("Category not found");
			}
		}
	},
	user: {
		start: function(id, query, render) {
			id = +id;
			return me.getUserPage(id, function(user, page, activity, ca, pages, userMap) {
				render(user, page, activity, ca, pages, userMap, id);
			})
		},
		render: function(user, page, activity, ca, pages, userMap, id) {
			$main.className = 'userMode';
			// todo: change edit box to "Joined: <date>" and "page edited: <date>"
			generateAuthorBox(user && page, userMap);
			
			$userPageAvatar.src = "";
			$userActivity.innerHTML = "";
			if (page) {
				$editButton.href = "#pages/edit/"+page.id;
				flag('canEdit', true);
			} else if (id == me.uid) {
				$editButton.href = "#pages/edit?type=@user.page&name=User Page";
				flag('canEdit', true);
			}
			if (user) {
				generatePath([["#users","Users"], ["#user/"+id, user.username]]);
				if (user.id == me.uid)
					flag('myUserPage', true);
				setTitle(user.username);
				if (page) {
					renderPageContents(page, $userPageContents)
				} else {
					$userPageContents.innerHTML = "";
				}
				userAvatar(user, $userPageAvatar, true);
				$userPageAvatarLink.href = user.rawAvatarURL;
				var lastId, lastAction;
				megaAggregate(activity, ca, pages).forEach(function(activity){
					if (activity.contentId != lastId || activity.action != lastAction) {
						if (activity.content) {
							$userActivity.appendChild(renderActivityItem(activity, activity.content));
							lastId = activity.contentId;
							lastAction = activity.action;
						}
					}
				});
			} else {
				generatePath([["#users","Users"], undefined]);
				$main.className = "errorMode";
				setTitle("User Not Found");
			}
		}
	},
	pages: {
		start: function(id, query, callback) {
			lp.onListeners = function(lists, users) {
				updateUserlist(lists[id], users)
			}
			lp.onMessages = function(messages, users, pages) {
				messages.forEach(function(comment) {
					var user = users[comment.createUserId];
					if (comment.parentId == id)
						displayMessage(comment, user);
				})
			}
			lp.setViewing(id);
			var linked = query["#"];
			if (linked && /^comment-/.test(linked)) {
				linked=+linked.substr(8);
			} else {
				linked = null;
			}
			return me.getPage(id, function(page, users, comments){
				callback(page, users, comments, query);
			});
		},
		render: function(page, users, comments, query) {
			$main.className = "pageMode";
			generateAuthorBox(page, users);
			flag('canEdit', !!page);
			if (page) {
				flag('page', true);
				scroller.switchRoom(page.id);
				generatePagePath(page, users);
				currentPage = page.id;
				currentChatRoom = page.id;
				var icon = "page";
				if (!hasPerm(page.permissions, 0, 'r'))
					icon = "hiddenpage"
				setTitle(page.name, icon);
				$watchCheck.checked = page.about.watching;
				// todo: handle showing/hiding the vote box when logged in/out
				renderPageContents(page, $pageContents)
				handleLoads($pageContents);
				displayGap();
				comments && comments.reverse().forEach(function(comment) {
					if (comment.parentId == page.id)
						displayMessage(comment, users[comment.createUserId]);
				});
				$editButton.href = "#pages/edit/"+page.id;
				$voteCount_b.textContent = page.about.votes.b.count;
				$voteCount_o.textContent = page.about.votes.o.count;
				$voteCount_g.textContent = page.about.votes.g.count;
				["b","o","g"].forEach(function(vote) {
					window['$voteCount_'+vote].textContent = page.about.votes[vote].count;
					attr(window['$voteButton_'+vote], 'data-selected', page.about.myVote == vote ? "" : undefined);
				});
				
				var photos = page.values.photos;
				visible($gallery, photos);
				if (photos) {
					photos = photos.split(",").map(function(x){return +x});
					$galleryImage.src = me.fileUrl(photos[0]);
				}
				var keyinfo = parseJSON(page.values.keyinfo);
				var key = page.values.key;
				var supported = parseJSON(page.values.supported);
				flag('hasKey', !!key);
				
				if (key) {
					$metaKey.textContent = key;
					$metaKey.className = "metaKey textItem";
					
					sbapi(key, function(data) {
						if (!data) {
							$metaKey.className += " invalidKey";
						} else if (!data.available) {
							$metaKey.className += " brokenKey";
						}
						renderKeyInfo(key, data, $sbapiInfo)
					})
				} else {
					$metaKey.textContent = "";
					$sbapiInfo.innerHTML = "";
				}
				if (query["#"]) {
					var comment=document.getElementById("_anchor_"+query["#"])
					if (comment) {
						comment.scrollIntoView()
						comment.setAttribute("data-linked", "");
					}
				}
			} else {
				currentPage = null;
				setTitle("Page not found");
				generatePath();
				$main.className = "errorMode";
			}
		}
	},
	"": {
		render: function(id, query, callback) {
			$main.className = "homeMode";
			generatePath();
			setTitle("Welcome to smilebnasic source! 2");
		}
	},
	'categories/edit': {
		start: function(id, query, callback) {
			return me.getCategoryForEditing(id, function(cat) {
				callback(cat, query);
			})
		},
		render: function(cat, query) {
			$main.className = 'cateditMode';
			if (cat) {
				visible($cateditSubmit, /u/.test(cat.myPerms));
				setTitle("Editing Category:");
				editingCategory = cat;
			} else {
				setTitle("Creating Category:");
				editingCategory = newCategory(query);
			}
			fillCateditFields(editingCategory);
		}
	},
	// idea: when editing, store the parent category/whatever somewhere, to tell where to go back to when deleting/ and also a way to send you to your user page when editing that I guess.

	'pages/edit': {
		start: function(id, query, callback) {
			return me.getPageForEditing(id, function(page, users) {
				callback(page, users, query);
			});
		},
		render: function(page, users, query) {
			$main.className = "editorMode";
			//todo: detect create perm properly (on category)
			// annoying thing is, when logging in to a page,
			// would need to re-request myperms hmm
			// maybe just have proper error handling?
			var canEdit = (!page && me.auth) || /u/.test(page.myPerms)
			visible($deletePage, page && /d/.test(page.myPerms));
			visible($submitEdit, canEdit);
			generateAuthorBox(page, users);
			//todo: set buttons to "disabled" instead maybe
			// and add explanation of permissions?
			//make it more clear when you can't modify page, especially
			
			if (page) {
				setTitle(canEdit ? "Editing:" : "Viewing Source:");
				editingPage = page;
			} else {
				setTitle("Creating:");
				editingPage = newPage(query);
				$titleInput.focus();
			}
			fillEditorFields(editingPage);
		}
	},
	usersettings: {
		start: function(id, query, render) {
			if (me.auth) {
				return me.getSettings(function(user, page) {
					render(user, page)
				});
			} else {
				render();
			}
		},
		render: function(user, page) {
			if (user) {
				$main.className = "settingsMode";
				generateAuthorBox();
				generatePath([["#usersettings","Settings"]]);
				setTitle("User Settings: " + user.username);
			} else {
				$main.className = "errorMode";
				setTitle("WHAT IS YOUR NAME?");
			}
		}
	},
	test: {
		render: function(id, query) {
			setTitle("Testing");
			$main.className = "testMode";
		}
	},
	error: {
		render: function(id, query, type) {
			$main.className = "errorMode";
			setTitle("[404] I DON'T KNOW WHAT A \""+type+"\" IS");
		}
	}
}

//bug: when going back from another site, page is loaded from cache, and
// certain things are not reloaded

// idea: 'protected' mode, during page editing
// gives warning before navigation
// or: just save editing page contents lol

var me = new Myself(true);
me.loadCachedAuth(function(){});
var scroller;
var lp = new LongPoller(me, null);
var currentPage;
flag('sidebar', localStorage.getItem('sbs-sidebar') == 'true');

debugMessage = function(text) {
	scroller.embed(renderSystemMessage(String(text)));
}

if (document.readyState == 'loading')
	document.addEventListener('DOMContentLoaded', ready);
else {
	ready();
}

function setUserCSS(text) {
	$userCSS.textContent = text;
}

function ready() {
	var userCSS = localStorage.userCSS;
	if (userCSS) {
		setUserCSS(userCSS);
	}
	
	if (me.openRequests) {
		loadStart();
	}
	me.onLoadStart = loadStart;
	me.onLoadEnd = loadEnd;
	console.info("ready");
	if (me.auth)
		onLogin(me);
	else
		onLogout();

	me.onLogin = onLogin;
	me.onLogout = onLogout;

	me.getVariable("userCSS", function(css) {
		if (css != null)
			setUserCSS(userCSS);
	});
	
	$loggedOut.$login.onclick = function() {
		event.preventDefault();
		me.logOut();
		me.logIn($loggedOut.$username.value, $loggedOut.$password.value, function(){});
	}
	$logout.onclick = function() {
		event.preventDefault();
		me.logOut();
	}

	$editorTextarea.oninput = function() {
		updateEditorPreview(true);
	}
	$markupSelect.onchange = function() {
		updateEditorPreview(true);
	}
	$markupUpdate.onclick = function() {
		updateEditorPreview(false);
	}

	$submitEdit.onclick = submitEdit;
	$cateditSubmit.onclick = cateditSubmit;
	$deletePage.onclick = deletePage;
	
	$chatSend.onclick = function() {
		if ($chatTextarea.value && currentChatRoom) {
			me.postComment(currentChatRoom, $chatTextarea.value, "", function(){});
			$chatTextarea.value = "";
		}
	}

	$chatTextarea.onkeypress = function(e) {
		if (!e.shiftKey && e.keyCode == 13) {
			e.preventDefault();
			$chatSend.onclick();
		}
	};

	var voteBtns = [$voteButton_b, $voteButton_o, $voteButton_g];
	var voteCounts = [$voteCount_b, $voteCount_o, $voteCount_g];
	// todo: update counts when changing
	var voteBlock;
	voteBtns.forEach(function(button, buttoni) {
		button.onclick = function(e) {
			if (voteBlock || !me.auth)
				return;
			var selected = button.getAttribute('data-selected');
			var vote = !selected ? button.getAttribute('data-vote') : null;
			voteBlock = true;
			me.setVote(currentPage, vote, function(e, resp){
				voteBlock = false;
				if (!e) {
					voteBtns.forEach(function(btn, i) {
						if (btn != button || selected) {
							if (btn.getAttribute('data-selected') != null) {
								voteCounts[i].textContent = +voteCounts[i].textContent - 1;
							}
							btn.removeAttribute('data-selected');
						}
					});
					//todo: update vote counts here;
					if (!selected) {
						button.setAttribute('data-selected', "true");
						voteCounts[buttoni].textContent = +voteCounts[buttoni].textContent + 1;
						//increment
					}
				}
			});
		}
	})

	var blockWatch
	$watchCheck.onchange = function() {
		if (blockWatch)
			return;
		blockWatch = true;
		me.setWatch(currentPage, $watchCheck.checked, function(){
			blockWatch = false;
		});
	}
	
	$registerForm.$register.onclick = function(e) {
		e.preventDefault();
		$registerError.textContent = "";
		var email = $registerForm.email.value;
		me.register($registerForm.username.value, $registerForm.password.value, email, function(e, resp) {
			if (e == 'error' && resp) {
				var errors = ["Registration failed:"];
				if (resp.errors) {
					for (var key in resp.errors) {
						errors.push(resp.errors[key].join(" "));
					}
				} else
					errors.push(resp);
				$registerError.textContent = errors.join("\n");
			} else if (!e) {
				$registerError.textContent = "Sending email...";
				me.sendEmail(email, function(e, resp){
					if (!e) {
						$registerError.textContent = "Confirmation email sent";
					} else {
						$registerError.textContent = "Error sending confirmation email";
					}
				});
			}
		});
	}
	$resendEmail.onclick = function(e) {
		me.sendEmail($registerForm.email.value, function(e, resp){
			if (!e) {
				$registerError.textContent = "Confirmation email sent";
			} else {
				$registerError.textContent = "Error sending confirmation email";
			}
		});
	}
	$registerConfirm.onclick = function() {
		// todo: validate the key client-side maybe
		me.confirmRegister($emailCode.value, function(e, resp) {
			if (!e) {
				$registerError.textContent = "Registration Complete";
				window.location.hash = "#user/"+me.uid;
			} else {
				$registerError.textContent = "Failed to confirm registration";
			}
		});
	}
	
	scroller = new AutoScroller($messageList);

	hashChange(true);
	/*$reload.onclick = function(){
		hashChange();
	}*/

	$openSidebar.onclick = $closeSidebar.onclick = toggleSidebar;
	
	$setAvatarButton.onclick = function() {
		if (selectedFile && selectedFile.id) {
			me.setBasic({avatar: selectedFile.id}, function(e) {
				if (!e) {
					updateAvatar(selectedFile);
				}
			});
		}
	}

	$fileUploadButton.onclick = function() {
		if (selectedFile instanceof File) {
			me.uploadFile(selectedFile, function(e, resp) {
				if (!e) {
					selectFile(resp);
				}
			});
		}
	}
	
	$fileUpload.onchange = function(e) {
		var file = this.files[0]
		if (file) {
			selectUploadedFile(file);
		}
	}

	$fileUpdateButton.onclick = function() {
		if (selectedFile && selectedFile.id) {
			readFileFields(selectedFile);
			me.putFile(selectedFile, function(e, resp) {
			});
		}
	}

	$submitUserSettings.onclick = submitUserSettings;

	$testButton.onclick = function() {
		var c = $testTextarea.value;
		$testOut.textContent="Starting..."
		try {
			var res = eval(c);
			$testOut.textContent="Finished:\n"+res;
		} catch(e) {
			$testOut.textContent="Error:\n"+res;
		}
	}

	$saveUserCSS.onclick = function() {
		var css = $settingsUserCSS.value;
		localStorage.userCSS = css;
		me.setVariable("userCSS", css, function(){});
		setUserCSS(css);
	}

/*	document.body.onclick = function(e) {
		console.log(e.target)
	}*/
}

function updateAvatar(file) {
	$myAvatar.src = me.avatarURL(file.id);
	//todo;
}

function toggleSidebar() {
	if (!window.matchMedia || window.matchMedia("(max-width: 700px)").matches) {
		flag('mobileSidebar', !flags.mobileSidebar);
	} else {
		flag('sidebar', !flags.sidebar);
		localStorage.setItem('sbs-sidebar', flags.sidebar);
	}
}

var currentPath = null;

function silentSetFragment(fragment) {
	cancelhashchange = true;
	location.hash = fragment;
	cancelhashchange = false;
}

// todo: add a "force" flag
function hashChange(first) {
	var fragment = getPath();
	// append # to the end of fragment links,
	// and it will be removed, so every time you clikc the link it will scroll
	if (fragment[2] == "") {
		silentSetFragment(location.hash.slice(0,-1));
	}
	if (currentPath == fragment[0]) {
		scrollTo(fragment[1])
	} else {
		currentPath = fragment[0];
		navigateTo(fragment[0], first, function() {
			scrollTo(fragment[1])
		}, fragment[1]);
	}
	
}

function scrollToAuto() {
	var fragment = getPath();
	if (fragment[1])
		scrollTo(fragment[1]);
}

function scrollTo(name) {
	//todo: this needs to happen after all images load etc. somehow...
	if (name) {
		var n = document.getElementsByName("_anchor_"+name)[0] || document.getElementById("_anchor_"+name);
		console.log("ANCHOR",n,name);
		if (n)
			n.scrollIntoView();
	}
}

var cancelhashchange
window.onhashchange = function() {
	if (cancelhashchange) {
		cancelhashchange = false;
		return;
	}
	
	// todo: when a link which has the same path but a different fragment is clicked,
	// page should not reload, instead just scroll to fragment
	hashChange(false);
}

function getPath() {
	var hash = decodeURIComponent(location.hash.substr(1));
	return hash.split("#");
}

function split1(string, sep) {
	var n = string.indexOf(sep);
	if (n == -1)
		return [string, null];
	else
		return [string.substr(0,n), string.substr(n+sep.length)];
}

var cancel;
function navigateTo(path, first, callback, hash) {
	if (cancel)
		cancel();
	path = split1(path, "?");
	var query = path[1];
	var queryVars = {"#":hash};
	if (query) {
		query.split("&").forEach(function(item) {
			item = split1(item, "=");
			if (item[1] == null) {
				queryVars[item[0]] = true;
			} else {
				queryVars[item[0]] = item[1];
			}
		});
	}
	path = path[0].split("/").filter(function(x){return x;});

	var type = path[0] || "";
	var id = +(path[1]) || 0;
	var name;	
	if (path[1] == 'edit') {
		id = path[2]!=undefined && +path[2];
		type = type + "/" + path[1];
	}
	cancel = doView(type, id, queryVars, callback);
}

function doPage(mode, func, id, query, callback, first) {
	func(id, query, callback);
}

function makeCategoryPath(tree, id, leaf) {
	var node = tree.map[id];
	var path = [];
	while (node) {
		path.unshift(["#categories/"+node.id, node.name])
		node = node.parent;
	}
	if (leaf) {
		path.push(["#pages/"+leaf.id, leaf.name]);
	} else {
		path.push(null);
	}
	return path;
}

// These are used to signal to the user when content is loading
function loadStart(lp) {
	if (!lp)
		flag('loading', true);
}
function loadEnd(lp, e) {
	if (!lp) {
		flag('loading');
	}
}

//maybe turn the title <h1> into an input box
//so you can just edit the page title there
function submitEdit() {
	readEditorFields(editingPage);
	me.postPage(editingPage, function(e, resp) {
		if (e) {
			alert("ERROR");
		} else {
			window.location.hash = "#pages/"+resp.id;
			cleanUpEditor();
		}
	});
}

function cateditSubmit() {
	readCateditFields(editingCategory);
	me.postCategory(editingCategory, function(e, resp) {
		if (e) {
			alert("ERROR");
		} else {
			window.location.hash = "#categories/"+resp.id;
		}
	});
}

function deletePage() {
	if (editingPage && editingPage.id) {
		var result = confirm("Are you sure you want to delete this page?");
		if (result) {
			// once the page is deleted, it should take you to the category (I guess)
			me.deletePage(editingPage.id, function(e, resp) {
				if (e) {
					alert("ERROR");
				} else {
					window.location.hash = "#categories/"+editingPage.parentId;
				}
			});
		}
	}
}

var editorCache = {video:{},audio:{},youtube:{}};
function updateEditorPreview(preview) {
	var parent = $editorPreview;
	var shouldScroll = parent.scrollHeight-parent.clientHeight-parent.scrollTop < 10
	renderPageContents({
		values: {
			markupLang: $markupSelect.value
		},
		content: $editorTextarea.value
	}, $editorPreview, editorCache);
	// auto scroll down when adding new lines to the end (presumably)
	if (shouldScroll) {
		parent.scrollTop = parent.scrollHeight-parent.clientHeight;
	}
}

// "generate" functions operate implicitly on specific html elements, and should be in view.js
// "render" functions often are similar but more general, and are in render.js
// I feel like the names are backwards, sorry...
function generateAuthorBox(page, users) {
	renderAuthorBox(page, users, $authorBox);
}

function onLogin(me) {
	//var me = this;
	me.whenUser(me.uid, function(user) {
		userAvatar(user, $myAvatar);
		$myName.textContent = user.username;
		$myUserLink.href = "#user/"+user.id;
	});
	flag("loggedIn",true);
	/*hashChange(false);*/
	lp.onMessages = function(messages, users, pages) {
	}
	lp.onActivity = function(activity, users, pages) {
	}
	lp.onBoth = function(resp) {
		sbm(resp.chains);
	}
	lp.onStatus = function(text) {
		$longPollStatus.textContent = text;
	}
	me.doListenInitial(function(e, resp){
		if (!e) {
			var lastId = -1
			resp.comment.forEach(function(comment) {
				if (comment.id > lastId)
					lastId = comment.id;
			});
			resp.activity.forEach(function(comment) {
				if (comment.id > lastId)
					lastId = comment.id;
			});
			sbm(resp);
			lp.lastId = lastId
			lp.start();
		}
	})
}

function sbm(resp) {
	console.log(resp);
	if (!(resp.comment && resp.content && resp.activity))
		return;
	var users = resp.userMap;
	var last = {};
	var all = megaAggregate(resp.activity, resp.comment, resp.content);
	all.reverse().forEach(function(activity){
		if (activity.contentId != last.contentId || activity.action != last.action || activity.userId != last.userId) {
			if (activity.content) {
				if (activity.userId instanceof Array)
					var user = activity.userId.map(function(x){
						return users[x];
					})
				else
					user = users[activity.userId]
				$sidebarActivity.insertBefore(renderActivityItem(activity, activity.content, user, true), $sidebarActivity.firstChild);
				last = activity;
			}
		}
	});
}

function onLogout() {
	lp.cancel[0]();
	$myAvatar.src = "";
	$myName.textContent = "";
	flag("loggedIn");
}

// maybe at bottom of sidebar (or top?)
// put list of active pages
//
// also still need to deal with
// old message deletion and old room clearing
// ugh
</script>
<style id="$userCSS"></style>
<body class="" id="$main">
	<!--
		 Nav bar 
	  -->
	<nav class="navPane bar">
		<a href="#" class="textItem"><img class="item" src="images/iconbig.png?a" alt="SBS"></a> <span id="$navPane" class="path textItem"></span>
		<span class="rightAlign textItem">
			<div class="buttonContainer item"><button id="$openSidebar">|||</button></div><!--<button id="$reload" class="item">Reload</button>--><!--<input id="$search" placeholder="Search" class="item">--><div class="loggedIn textItem" id="$loggedIn"><a class="item userLink" id="$myUserLink"><span class="myName username textItem" id="$myName" class="item"></span><img class="myAvatar item avatar" id="$myAvatar"></a></div>
		</span>
	</nav>
	
	<header class="titlePane bar rem2-3" id="$titlePane">
		<span id="$pageTitleIcon"></span><h1 class="pageTitle textItem pre" id="$pageTitle"></h1><a class="textItem userMode loggedIn myUserPage" href="#usersettings">Settings</a><div class="buttonContainer item loggedIn myUserPage"><button id="$logout">Log Out</button></div><input class="item editorMode" id="$titleInput" placeholder="Page Title" required><input class="item cateditMode" id="$cateditTitle" placeholder="Category Title" required><div class="buttonContainer item editorMode"><button id="$submitEdit" >Submit</button></div><span class="cateditMode textItem"><div class="buttonContainer item"><button id="$cateditSubmit">Submit</button></div></span><span class="textItem pageMode" id="$voteBox"><div class="buttonContainer item"><button id="$voteButton_b" class="voteButton" data-vote="b">Bad<br><span id="$voteCount_b">x</span></button></div><div class="buttonContainer item"><button id="$voteButton_o" class="voteButton" data-vote="o">Ok<br><span id="$voteCount_o">x</span></button></div><div class="buttonContainer item"><button id="$voteButton_g" class="voteButton" data-vote="g">Great<br><span id="$voteCount_g">x</span></button></div></span>
		<label for="$watchCheck" class="textItem pageItem loggedIn">Watching:</label>
		<input type="checkbox" id="$watchCheck" class="item pageItem loggedIn">

		<div class="pageCreate textItem rightAlign">
			<span class="textItem" id="$authorBox"></span><div class="buttonContainer editorMode item"><button id="$deletePage">DELETE</button></div><div class="buttonContainer item canEdit"><a id="$editButton"><button tabindex="-1">Edit</button></a></div>
		</div>
	</header>

	<div class="sideBarContainer">
		<div class="m">
			<div class="userlistPane userlist rem2-3 pageChatMode bar" id="$chatUserlist"></div>
			
			<div class="infoPane editorMode">
				<label for="$keywords">Keywords:</label><input placeholder="(space separated, optional)" id="$keywords"><br>
				<label for="$editPageType">Type:</label><input placeholder="@" id="$editPageType"><br>
				<label for="$editPageCategory">Category id:</label><input type="number" placeholder="id" id="$editPageCategory"><br>
				<label for="$permissions">Permissions:</label><input id="$permissions"><br>
				<label for="$markupSelect">Markup language:</label>
				<select id="$markupSelect">
					<option value="plaintext">plain text</option>
					<option value="12y">12-y documentation markup format</option>
					<option value="bbcode">bbcode</option>
				</select><button id="$markupUpdate">Update Preview</button>
			</div>

			<div class="fileMode fileNav rem1-7 nav">
				<div class="buttonContainer item"><a id="$filePrev"><button>&lt;</button></a></div><div class="buttonContainer item"><a id="$fileNext"><button>&gt;</button></a></div><span class="textItem" id="$filePageNumber"></span><input type="file" id="$fileUpload" accept="image/*" class="item loggedIn">
			</div>

			<div class="fileMode fileBox bar" id="$fileBox">
			</div>

			<div class="fileMode">
				<div class="buttonContainer fileUploading"><button id="$fileUploadButton">Upload Image!</button></div>
				<div class="fileSelected">
					<div class="buttonContainer loggedIn"><button id="$setAvatarButton">Use As Avatar</button></div>
					<table class="form">
						<tr>
							<th>User:</th>
							<td id="$fileUser"></td>
						</tr>
						<tr>
							<th><label for="$fileName">Name:</label></th>
							<td><input id="$fileName"></td>
						</tr>
						<tr>
							<th><label for="$fileName">Permissions:</label></th>
							<td><input id="$filePermissions"><br></td>
						</tr>
						<tr>
							<th><label for="$fileName">Values:</label></th>
							<td><input id="$fileValues"></td>
						</tr>
					</table>
					<div class="buttonContainer canEdit loggedIn"><button id="$fileUpdateButton" class="fileUpdateButton">Save Settings</button></div>
				</div>
			</div>
			
			
			<div class="activityMode categoryNav rem1-7 nav bar">
				<span class="textItem">
					<div class="buttonContainer item">
						<a id="$activityPagePrev"><button>&lt;</button></a>
					</div><div class="buttonContainer item">
						<a id="$activityPageNext"><button>&gt;</button></a>
					</div><span class="textItem" id="$activityPageNumber"></span>
				</span>
			</div>
			
			<div class="membersMode memberNav nav">

				<span class="textItem">
					<div class="buttonContainer item">
						<a id="$membersPrev">
							<button>&lt;</button>
						</a>
					</div><div class="buttonContainer item">
						<a id="$membersNext">
							<button>&gt;</button>
						</a>
					</div>
				</span>
			</div>



			<div class="userPageBox userMode">
				<a id="$userPageAvatarLink"><img id="$userPageAvatar" class="userPageAvatar avatar"></a>
				<div class="pageContents pre userPageContents" id="$userPageContents"></div>
			</div>
			
			<!--
				 These panes have the main content
				 one of them will be visible at a time, depending on the view mode
			  -->
			
			<main>
				<div class="cateditMode">
					<label for="$cateditPinned">Pinned pages:</label><input id="$cateditPinned"><br>
					<label for="$cateditCategory">Parent category:</label><input id="$cateditCategory" type="number"><br>
					<label for="$cateditPermissions">Permissions:</label><input id="$cateditPermissions"><br>
					<textarea id="$cateditDescription"></textarea><br>
				</div>
				
				<div id="$categoryDescription" class="categoryDescription pre pageContents categoryMode"></div>
				<div id="$categoryCategories" class="categoryMode"></div>
				<div id="$categoryPinned" class="categoryMode"></div>
				<div class="categoryMode categoryNav rem1-7">
					<span class="buttonContainer item">
						<button id="$categoryPagesPrev">&lt;</button>
					</span><span class="buttonContainer item">
						<button id="$categoryPagesNext">&gt;</button>
					</span>
					<span class="textItem" id="$categoryPageNumber"></span>
					<span class="buttonContainer item"><a id="$categoryCreatePage"><button>Create Page</button></a></span>
				</div>
				<div id="$categoryPages" class="categoryPages categoryMode"></div>

				<div class="userActivity userMode" id="$userActivity"></div>

				<div class="pageInfoPane pageMode px40" id="$pageInfoPane">
					<span id="$gallery" class="gallery" style="display:none;"><button id="$galleryPrev" class="galleryButton">&lt;</button><img id="$galleryImage"><button id="$galleryNext" class="galleryButton rightAlign">&gt;</button></span>
					<span class="metaInfo">
						<span id="$metaKey" class="textItem"></span>
						<span id="$sbapiInfo" class="textItem"></span>
					</span>
					<!-- here we can put
						  tags, type, sb key info, etc.
					  -->
				</div>
				<div class="pageContents pre pageChatMode" id="$pageContents"></div>
				<div class="spacer pageChatMode"></div>

				<div id="$messageList" class="messageList pageChatMode"></div>
				
				<div class="editorPane editorMode">
					<div class="editorTextarea">
						<textarea id="$editorTextarea" minlength="2" required=""></textarea>
					</div>
					<div class="editorPreview" id="$editorPreview"><div class="markup-root" ></div></div>
				</div>
				
				<div class="homeMode homePane">
					<a class="categoryPage bar rem2-3" href="#activity"><span class="textItem">Activity</span></a>
					<a class="categoryPage bar rem2-3" href="#categories/0"><span class="textItem">Pages</span></a>
					<a class="categoryPage bar rem2-3" href="#users"><span class="textItem">Users</span></a>
					<a class="categoryPage bar rem2-3" href="#files"><span class="textItem">Images</span></a>
					<a class="categoryPage bar rem2-3" href="#test"><span class="textItem">Test</span></a>
				</div>
				<div class="membersMode memberPane">
					<div id="$memberList"></div>
				</div>

				<div class="registerMode">
					<form id="$registerForm">
						<input name="username" type="username" placeholder="Username" required minlength="3"><br>
						<input name="password" type="password" placeholder="Password" minlength="8" required><br>
						<input name="email" type="email" placeholder="Email" required><br>
						<button id="$register" onclick="event.preventDefault()">Register</button>
					</form>
					<button id="$resendEmail" onclick="event.preventDefault()">Resend Email</button>
					<div id="$registerError" class="pre"></div>
					<input id="$emailCode" placeholder="Confirmation Code"><br>
					<button id="$registerConfirm">Confirm</button>
				</div>

				<div class="settingsMode loggedIn">
					<table class="form">
						<tr><td><label for="$settingsOldPassword">Old Password: </label></td><td><input type="password" id="$settingsOldPassword" required=""><td></tr>
						<tr><td><label for="$settingsUsername">New Username (Optional): </label></td><td><input autocomplete="off" id="$settingsUsername"></td></tr>
						<tr><td><label for="$settingsNewPassword">New Password (Optional): </label></td><td><input autocomplete="new-password" type="password" id="$settingsNewPassword"></td></tr>
						<tr><td><label for="$settingsEmail">New Email (Optional): </label></td><td><input autocomplete="off" type="email" id="$settingsEmail"></td></tr>
					</table>
					<button id="$submitUserSettings">Save</button>
					<hr>
					<a href="#files">Change your avatar here</a>
					<hr>
					<label for="$settingsUserCSS">User CSS:</label><br>
					<textarea id="$settingsUserCSS"></textarea><br>
					<button id="$saveUserCSS">Save</button>
				</div>

				<div class="activityMode" id="$activity">
				</div>


				<div class="fileMode fileViewPane">
					<img id="$fileView" class="fileView">
				</div>

				<div class="testMode">
					<textarea id="$testTextarea"></textarea><br>
					<button id="$testButton">Run</button><br>
					<div id="$testOut" class="pre"></div>
				</div>
				
				<div class="bottomSpacer"></div>
			</main>
			
			<!--
				 Bottom of the page
			  -->
			<div class="inputPane pageChatMode">
				<textarea id="$chatTextarea"></textarea>
				<div class="buttonContainer"><button id="$chatSend">Send</button></div>
			</div>

		</div>
		
		<div class="sideBar" id="$sidebar">
			<div class="buttonContainer closeSidebar"><button id="$closeSidebar">Close Sidebar</button></div><br>
			<form class="textItem loggedOut" id="$loggedOut"><a href="#register">Register</a><br>
				<input id="$username" placeholder="username" name="username" class="item loginField"><input id="$password" type="password" name="password" placeholder="password" class="item loginField"><br>
				<button class="item" id="$login" onclick="event.preventDefault()">Log In</button></form>
			<div class="loggedIn">
				Long Poller: <span id="$longPollStatus"></span>
			</div>
			<div class="sidebarScroller" id="$sidebarScroller">
				<div id="$sidebarPinned"></div>
				<div id="$sidebarActivity"></div>
			</div>
		</div>
	</div>
</body>
