
<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="icon" sizes="16x16" href="favicon.ico?a"> <!-- compatibility -->
<link rel="shortcut icon" sizes="16x16" href="favicon.png?a"> <!-- firefox -->
<link rel="icon" sizes="32x32" href="icon32.png?a"> <!-- chrome -->
<link rel="icon" sizes="192x192" href="fav-big.png?b"> <!-- large -->
<link rel="apple-touch-icon" href="fav-big.png?b"> <!-- large 2 -->
<link rel="image_src" href="fav-big.png?b"> <!-- large 3 -->

<style>
@font-face{
	font-family:roboto;
	font-weight:400;
	font-style:normal;
	src:url(fonts/roboto-400.woff2) format('woff2'),url(fonts/roboto-400.woff) format('woff')
}
@font-face{
	font-family:roboto;
	font-weight:400;
	font-style:italic;
	src:url(fonts/roboto-400i.woff2) format('woff2'),url(fonts/roboto-400i.woff) format('woff')
}
@font-face{
	font-family:roboto;
	font-weight:700;
	font-style:normal;
	src:url(fonts/roboto-700.woff2) format('woff2'),url(fonts/roboto-700.woff) format('woff')
}
@font-face{
	font-family:roboto;
	font-weight:700;
	font-style:italic;
	src:url(fonts/roboto-700i.woff2) format('woff2'),url(fonts/roboto-700i.woff) format('woff')
}

/*@font-face{font-family:roboto mono;font-weight:400;font-style:normal;src:url(/fonts/roboto_mono/400.woff2) format('woff2'),url(/fonts/roboto_mono/400.woff) format('woff')}
@font-face{font-family:roboto mono;font-weight:400;font-style:italic;src:url(/fonts/roboto_mono/400i.woff2) format('woff2'),url(/fonts/roboto_mono/400i.woff) format('woff')}
@font-face{font-family:roboto mono;font-weight:700;font-style:normal;src:url(/fonts/roboto_mono/700.woff2) format('woff2'),url(/fonts/roboto_mono/700.woff) format('woff')}
@font-face{font-family:roboto mono;font-weight:700;font-style:italic;src:url(/fonts/roboto_mono/700i.woff2) format('woff2'),url(/fonts/roboto_mono/700i.woff) format('woff')}*/
* {
	margin: 0;
	box-sizing: border-box;
	-webkit-box-sizing: border-box;
	overflow-wrap: break-word;
	vertical-align: top;
}

/* html.loading * {
	cursor: progress !important;
}*/

html {
	background-color: red;
	font-family: roboto, sans-serif;
}

/* all elements with user content, where whitespace should be preserved */
.pre {
	white-space: pre-wrap;
}

a:visited {
	color: #00A;
}

.time {
	color: #333;
	font-size: 0.9em;
	vertical-align: baseline;
}

.avatar {
	border: 1px solid white;
}

a {
	text-decoration: none;
}

a:hover {
	color: #06F;
}

textarea {
	border-radius: 2px;
	border: 2px solid #00C8B4;
	box-shadow: 0.1rem 0.2rem 0.3rem -0.2rem rgba(13,13,13,0.5);
	max-width: 100%;
	font-size: 1em; /* prevent zoom in on iphone */
}

.scroller {
	display: -webkit-flex;
	display: flex;
	-webkit-flex-direction: column;
	flex-direction: column;
	overflow-y: auto;
	flex-basis: 0;
	/*min-height: 300px;
	height: 300px;*/
}

.spacer {
	-webkit-flex-grow: 1;
	flex-grow: 1;
}

.rightAlign {
	float: right;
}

/* These 3 classes handle like 90% of the layout lol */
.bar { /* contains textitems and items */
	display: block;
	overflow: hidden;
	box-sizing: content-box;
	-webkit-box-sizing: content-box;
	/* set min-height */
}
.textItem { /* basically anything within a .bar */
	max-width: 100%;
	display: inline;
	/* set min-height, line-height */
}
.item { /* for images and other blocks that can't wrap */
	display: inline-block;
	max-width: 100%;
	/* set height */
}

/****************************
 ** Main Container Element **
 ****************************/
body {
	display: -webkit-flex;
	display: flex;
	-webkit-flex-direction: column;
	flex-direction: column;
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	background-color: white;
}

body > *:not(:first-child), .editorPreview, .pagePane > *:not(:first-child):not(.spacer), .categoryPages {
	border-top: 1px solid gray;
}

/* most elements will be fixed-height, and should never shrink */
body > * {
	-webkit-flex-shrink: 0;
	flex-shrink: 0;
}

/* each view has one pane which takes up the remaining screen height */
.paneGrow {
	-webkit-flex-grow: 1;
	flex-grow: 1;
	-webkit-flex-shrink: 1;
	flex-shrink: 1;

	min-height: 100px;
	/*padding: 0.5rem;*/
	/*overflow-y: scroll;*/
}

/* visibility control */
body:not(.pageMode) .pageMode,
body:not(.chatMode) .chatMode,
body:not(.editorMode) .editorMode,
body:not(.categoryMode) .categoryMode,
body:not(.navMode) .navMode,
body:not(.userMode) .userMode,
body:not(.membersMode) .membersMode,
body:not(.registerMode) .registerMode,
body:not(.settingsMode) .settingsMode,
body:not(.activityMode) .activityMode,
body:not(.userMode):not(.pageMode) .pageUserMode,
body:not(.chatMode):not(.pageMode) .pageChatMode,
body:not(.homeMode) .homeMode {
	display: none;
}



/*************
 ** Top Bar **
 *************/
.headerPane {
	min-height: 1.5rem;
	background-color: #333;
}

html.f-loading .headerPane {
	background-color: #008;
}

html.f-error .headerPane {
	background-color: #800;
}

html:not(.f-loggedIn) .loggedIn,
html.f-loggedIn .loggedOut {
	display: none;
}

.headerRight {
	float: right;
}

.headerPane .item {
	height: 1.5rem;
}

.headerPane .textItem{
	min-height: 1.5rem;
	line-height: 1.5rem;
}

.myAvatar {
	width: 1.5rem;
}

.myName {
	color: white;
	margin: 0 0.5rem;
}

.path {
	font-weight: bold;
	color: white;
}

.headerPane a {
	color: #BCF;
}

.headerPane a:hover {
	color: #9AF;
}

.pathSeparator {
	padding: 0 0.2rem;
}

/****************
 ** Title Pane **
 ****************/
.titlePane {
	background-color: #DDD;
	padding: 0 0.5rem;
}

.titlePane .userLink img {
	margin: 0 0.7ch;
}

/* .item's are things like the site logo, user avatar, etc.*/
/* .textItem is similar, but is allowd to wrap */

.editingLabel {
	padding-left: 0.3rem;
	font-weight: bold;
}
.pageTitle {
	font-weight: bold;
	padding-right: 0.5rem;
	font-size: 1.6rem;
}

.errorMode .titlePane {
	background-color: pink;
	color: maroon;
	font-family: monospace;
}

/* Box showing the page author/editor */
.pageCreate {
	float: right;
}
.pageCreate {
	background-color: rgba(255,255,255,0.1);
}
.pageAuthorAvatar {
	width: 2.3rem;
}
.pageAuthorDate {
	padding-left: 0.5rem;
}
.pageAuthorName {
	padding: 0 0.5rem;
}
.pageEdited {
	border-left: 1px solid gray;
}

/*******************
 ** Category Pane **
 *******************/
.categoryPage {
	font-weight: bold;
	background-color: #EEE;
	padding-left: 0.4rem;
}
.categoryPage, .categoryDescription, .member {
	border-top: 1px solid gray;
}
.categoryPage .username {
	padding: 0 0.4rem;
}

.rem1-5 {
	min-height: 1.7rem;
}
.rem1-5 .item {
	height: 1.7rem;
	line-height: 1.7rem;
}
.rem1-5 .textItem {
	min-height: 1.7rem;
	line-height: 1.7rem;
}
.rem1-5 .avatar {
	width: 1.7rem;
}

.rem2-3 {
	min-height: 2.3rem;
}
.rem2-3 .item {
	height: 2.3rem;
	line-height: 2.3rem;
}
.rem2-3 .textItem {
	min-height: 2.3rem;
	line-height: 2.3rem;
}
.rem2-3 .avatar {
	width: 2.3rem;
}

/***************
 ** Page Pane **
 ***************/
.pageContents, .editorPreview {
	/*padding: 0.5rem;*/
}

/*******************
 ** Chat Userlist **
 *******************/
.userlist {
	background-color: #EEE;
}

/***********************
 ** Chat Message Pane **
 ***********************/
/* ... */
.messageList {
	padding-bottom: 0.7rem;
}

/** Chat Messages **/
.message {
	font-size: 0.9rem;
	padding: 0.4rem 0.5rem;
	white-space: pre-wrap;
	border-left-width: 0.5em;
	border-left-style: solid;
	border-left-color: rgb(255,153,153);
	clear: both;
	overflow: auto;
}
.systemMessage {
	background-color: rgba(187,187,187, 0.2);
	font-weight: bold;
	color: #666;
	border-left: 0.5em solid rgb(187,187,187);
}
.ownMessage {
	background-color: rgba(255,153,153, 0.2);
}
.messageTime {
	float: right;
	font-weight: normal;
	padding-right: .5em;
	color: #666;
}
.message .avatar {
	display: inline-block;
	width: 3.5rem;
	height: 3.5rem;
	border: 1px solid #777;
	margin-right: 0.5rem;
	float: left;
}
.messageUsername {
	display: inline-block;
}
.messageContents {
	display: block;
	vertical-align: top;
	overflow: auto;
}
.messagePart {
	margin: .2rem;
}
.messagePart img {
	max-width: 100%;
	max-height: 10vh;
	border: 1px solid silver;
}
/****************
 ** Chat Input **
 ****************/
.inputPane {
	height: 3.25rem;
	display: -webkit-flex;
	display: flex;
	-webkit-flex-direction: row;
	flex-direction: row;
}
.inputPane > * {
	height: 100%;
}
.inputPane > textarea {
	-webkit-flex-grow: 1;
	flex-grow: 1;
	resize: none;
	min-width: 0;
}

.inputPane > button {
	width: 3.25rem;
}

/**********************
 ** Editor Info Pane **
 **********************/

/*****************
 ** Editor Pane **
 *****************/
.editorPane {
	display: -webkit-flex;
	display: flex;
	-webkit-flex-direction: column;
	flex-direction: column;
	-webkit-flex-grow: 1;
	flex-grow: 1;
}

.editorPreview {
	-webkit-flex-grow: 1;
	flex-grow: 1;
	-webkit-flex-shrink: 1;
	flex-shrink: 1;
	overflow-y: scroll;
	-webkit-flex-basis: 0;
	flex-basis: 0;
	min-height: 10rem;
}

.editorTextarea > textarea {
	resize: vertical;
	width: 100%;
	height: 40vh;
	box-sizing: border-box;
}

/***************
 ** User Page **
 ***************/

.member {
	display: block;
	background-color: #EEE;
}

.memberName {
	padding: 0 0.5rem;
}

.bottomSpacer {
	-webkit-flex-shrink: 0;
	flex-shrink: 0;
	height: 1.5rem;
}

.listItem {
	background-color: #EEE;
	border-top: 1px solid gray;
	padding: 0 0.2rem;
}

.listItem a {
	font-weight: bold;
}

.userPageBox {
	align-items: flex-start;
	display: -webkit-flex;
	display: flex;
	-webkit-flex-direction: row;
	flex-direction: row;
	max-height: 40vh;
	overflow: auto;
	/* todo: make this outside of scroller and have activity list scroll separately*/
}

.userPageBox .userPageAvatar {
	width: 10rem;
	height: 10rem;
	display: inline-block;
	-webkit-flex-shrink: 1;
	flex-shrink: 1;
}

.userPageBox .pageContents {
	/*width: 10rem;*/
	flex-basis: 0;
}

.categoryNav {
	-webkit-flex-shrink: 0;
	flex-shrink: 0;
}

.loginField {
	width: 5rem;
}

button {
	line-height: normal !important;
}

img.item {
	vertical-align: top;
}

.userPageContents {
	
	-webkit-flex-grow: 1;
	flex-grow: 1;
}

.voteButton[data-selected] {
	background-color: lime;
}

/* hecko yo */
.pageContents {
	max-width:100%;
	overflow-x:auto;
	-webkit-flex-shrink: 0;
	flex-shrink: 0;
}

.listItem span {
	color: black;
}

.listItem .avatar {
	margin-right: 0.3ch;
}


.username {
	font-weight: bold;
}

.member .avatar {
	margin-right: 0.7ch;
}

.iframe {
	border: 1px solid red;
}

.bottomSpacer {
	border-top: 1px solid gray;
}

.sideBarContainer {
	display: flex;
	display: -webkit-flex;
	-webkit-flex-direction: row;
	flex-direction: row;
	-webkit-flex-grow: 1;
	flex-grow: 1;
	overflow-x: hidden;
}

.m {
	width:100%;
	-webkit-flex-grow: 1;
	flex-grow: 1;
	display: -webkit-flex;
	display: flex;
	-webkit-flex-direction: column;
	flex-direction: column;
}

.sideBar {
	-webkit-flex: 0 0 30vw;
	flex: 0 0 30vw;
	background-color: rgba(204, 221, 238, 0.9);
	border-left: 2px solid black;
	-webkit-transition: margin-left 0.25s ease, transform 0.25s ease;
	transition: margin-left 0.25s ease, transform 0.25s ease;
}

html:not(.f-sidebar) .sideBar {
	-webkit-transform: translateX(100%);
	transform: translateX(100%);
	margin-left: -30vw;
}

html:not(.f-myUserPage) .myUserPage {
	display: none;
}

/*@media (max-width: 700px) {
	.userPageBox {
		flex-direction: column;
		max-height: none;
	}
	.userPageContents {
		width: 100%;
	}
}*/

/* for devices with small screens */
@media (max-width: 700px), (max-height: 500px) {
	/* make sidebar fill screen */
	.sideBar {
		width: 100%;
		height: 100%;
		position: fixed;
		bottom: 0;
		right: 0;
		left: 0;
		border-left: none;
	}
	html:not(.f-sidebar) .sideBar {
		margin-left: 0;
	}
	.m {
		width: 100%;
	}

	/* make the entire page scroll */
	/* todo: make chat mode work better here */
	body {
		position: static;
		min-height: 100vh;
		font-size: 0.9em;
	}
	main {
		height: auto !important;
	}
	html {
		background-color: transparent;
	}
	/* smaller editor text area */
	.editorTextarea textarea {
		height: 20vh;
	}
	.userPageBox {
		max-height: none;
	}
	.scroller {
		flex-basis: auto;
	}
}


.markup-root {
	white-space: pre-wrap;
}

.markup-root table, .markup-root td, .markup-root th {
	border: 1px solid black;
	border-collapse: collapse;
}

.markup-root td, .markup-root th {
	padding: 0.2rem 0.3rem;
}

.markup-root table {
	margin: 0.25rem 0;
}

.markup-root * {
	vertical-align: baseline;
}

.markup-root h2, .markup-root h3 {
	border-bottom: 1px solid #eaecef;
	margin-bottom: 0.2rem;
}

.markup-root h2 {
	margin-top: 0.5rem;
}

.markup-root h3 {
	margin-top: 0.3rem;
}

.markup-root pre {
	font-family: consolas, monospace;
	color: white;
	background-color: black;
	white-space: pre-wrap;
}

.markup-root code {
	font-family: consolas, monospace;
	background-color: rgba(0,0,0,0.1);
	padding: 0 0.2rem;
}

.markup-root pre, .markup-root table {
	box-shadow: 2px 2px 2px #888888;
}

.markup-root pre {
	border: 1px solid black;
	padding: 0.5rem;
	margin: 0.25rem 0;
}

.markup-root {
	margin: 0.5rem;
}

.markup-root img {
	max-width: 100%;
	max-height: 10vh;
	display: block;
	-webkit-transition: all 0.25s ease;
	transition: all 0.25s ease;
}

.markup-root img:focus {
	max-height: 75vh;
}

.markup-root ul {
	padding-left: 1.1em;
}

.markup-root audio, .markup-root video, .markup-root .youtube {
	display: block;
}

.markup-root .youtube {
	width: 320px;
	max-height: none;
}
.markup-root pre {
	background-color: #000;
	color: #EEE;
}
.markup-root pre * {
	background-color: transparent;
}
.markup-root pre .name {
	color: #7FF5EF;
}
.markup-root pre .string {
	color: #59EE79;
}
.markup-root pre .number {
	color: #f359ab;
}
.markup-root pre .keyword {
	font-weight: bold;
	color: #2494f0;
}
.markup-root pre .comment {
	color: #a1f198;
}
.markup-root pre .variable {
	color: #fbf4cb;
}
.markup-root pre .function {
	color: #8d7ff5;
}
.markup-root pre .statement {
	color: #7ff5ef;
}
.markup-root pre .backslash {
	color: #777;
}
.markup-root pre .operator {
	color: #EEE;
}
.markup-root pre .equals {
	color: #EEE;
}

.markup-root pre .label {
	color: #f4963e;
}

.markup-root pre .word-operator {
	color: #2494f0;
}
.markup-root pre .to-step {
	color: #2494f0;
}
.markup-root pre .constant {
	color: #aeb5c2;
}


/*--highlight-question: #2494f0;*/

</style>
<script>
/******************
 ** EVENT SYSTEM **
 ******************/
// based on nodejs EventEmitter
// ok I like, never even use this...
// should I really keep it even..

function EventEmitter() {
	this.events = {};
}

EventEmitter.prototype.on = function(name, func) {
	if (this.events[name]) {
		return this.events[name].push(func)-1;
	} else {
		this.events[name] = [func];
		return 0;
	}
}

EventEmitter.prototype.removeListener = function(name, item) {
	var events = this.events[name]
	if (!events)
		return false;
	// this takes either an index (returned by .on) or a function reference
	if (item instanceof Function) {
		item = events.indexOf(item);
		if (item==-1)
			return false;
	}
	if (events[item]) {
		events[item] = undefined;
		return true;
	}
	return false;
}

EventEmitter.prototype.emit = function(name) {
	var $=this;
	var events = $.events[name];
	var args = Array.prototype.slice.call(arguments, 1);
	if (events) {
		events.forEach(function(event) {
			if (event) {
				event.apply($, args);
			}
		});
	}
}
// Source: https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Local_storage

if (!window.localStorage) {
	window.localStorage = {
		getItem: function (sKey) {
			if (!sKey || !this.hasOwnProperty(sKey)) { return null; }
			return unescape(document.cookie.replace(new RegExp("(?:^|.*;\\s*)" + escape(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*"), "$1"));
		},
		key: function (nKeyId) {
			return unescape(document.cookie.replace(/\s*\=(?:.(?!;))*$/, "").split(/\s*\=(?:[^;](?!;))*[^;]?;\s*/)[nKeyId]);
		},
		setItem: function (sKey, sValue) {
			if(!sKey) { return; }
			document.cookie = escape(sKey) + "=" + escape(sValue) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/";
			this.length = document.cookie.match(/\=/g).length;
		},
		length: 0,
		removeItem: function (sKey) {
			if (!sKey || !this.hasOwnProperty(sKey)) { return; }
			document.cookie = escape(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
			this.length--;
		},
		hasOwnProperty: function (sKey) {
			return (new RegExp("(?:^|;\\s*)" + escape(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
		}
	};
	window.localStorage.length = (document.cookie.match(/\=/g) || window.localStorage).length;
}
function sbs2Request(url, method, callback, data, auth, cancel) {
	var x = new XMLHttpRequest();
	if (cancel)
		cancel[0] = function() {x.abort();};
	x.open(method, url);

	var start = Date.now();
	x.onload = function() {
		var code = x.status;
		var type = x.getResponseHeader('Content-Type');
		if (/^application\/json(?!=\w)/.test(type)) {
			try {
				var resp = JSON.parse(x.responseText);
			} catch(e) {
				resp = null;
			}
		} else {
			resp = x.responseText;
		}
		if (code==200) {
			callback(null, resp);
		} else if (code==408 || code==204) {
			// record says server uses 408, testing showed only 204
			// basically this is treated as an error condition,
			// except during long polling, where it's a normal occurance
			callback('timeout', resp);
		} else if (code==401) {
			console.log(x);
			callback('auth', resp);
		} else {
			alert("Request failed! "+code+" "+url);
			//console.log("sbs2Request: request failed! "+code);
			//console.log(x.responseText);
			console.log("REQUEST FAILED", x);
			try {
				resp = JSON.parse(resp);
			} catch(e) {
			}
			callback('error', resp, code);
		}
	}
	x.onerror = function() {
		var time = Date.now()-start;
		console.log("xhr onerror after ms:"+time);
		if (time > 18*1000) {
			console.log("detected 3DS timeout");
			callback('timeout');
		} else {
			alert("Request failed! "+url);
			console.log("xhr onerror");
			callback('fail');
		}
	}
	x.setRequestHeader('Cache-Control', "no-cache, no-store, must-revalidate");
	x.setRequestHeader('Pragma', "no-cache"); // for internet explorer
	if (auth)
		x.setRequestHeader('Authorization', "Bearer "+auth);
	
	if (data) {
		if (data && data.constructor == Object) { //plain object
			x.setRequestHeader('Content-Type',"application/json;charset=UTF-8");
			x.send(JSON.stringify(data));
		} else { //string, formdata, arraybuffer, etc.
			x.send(data);
		}
	} else {
		x.send();
	}
}

function queryString(obj) {
	if (!obj)
		return "";
	var items = [];
	for (var key in obj) {
		var val = obj[key];
		if (typeof val != 'undefined'){
			var item = encodeURIComponent(key)+"=";
			// array items are encoded as
			// ids:[1,2,3] -> ids=1&ids=2&ids=3
			
			if (val instanceof Array) {
				for(var i=0;i<val.length;i++){
					items.push(item+encodeURIComponent(val[i]));
				}
			// otherwise, key=value
			} else {
				items.push(item+encodeURIComponent(val));
			}
		}
	}
	
	if (items.length)
		return "?"+items.join("&");
	else
		return "";
}

function Myself(isDev) {
	EventEmitter.call(this);
	this.userCache={};
	this.userRequests={};
	this.selectServer(isDev);
	this.openRequests = 0;
}
Myself.prototype = Object.create(EventEmitter.prototype);
Object.defineProperty(Myself.prototype, 'constructor', {
	value: Myself,
	enumerable: false,
	writable: true
});

function https() {
	if (window.location.protocol=="http:")
		return "http:";
	return "https:";
}

// Select/switch which server to use (dev or normal)
// this should clear internal cache etc.
// todo: maybe allow switching signed in accounts
Myself.prototype.selectServer = function(isDev) {
	this.logOut(true);
	if (isDev) {
		this.server = https() + "//newdev.smilebasicsource.com/api";
		this.lsKey = "devauth"
	} else {
		this.server = https() + "//new.smilebasicsource.com/api";
		this.lsKey = "auth"
	}
}

Myself.prototype.request = function(url, method, callback, data, cancel) {
	var $=this;
	$.openRequests++;
	$.loadStart(!!cancel);
	sbs2Request($.server+"/"+url, method, function(e, resp) {
		$.openRequests--;
		$.loadEnd(!!cancel, e);
		/*if (e=='auth') {
			$.logOut();
		}*/
		$.cb(callback, e, resp);
	}, data, $.auth, cancel);
}

Myself.prototype.loadStart = function(lp) {
	if (this.onLoadStart)
		this.cb(this.onLoadStart, lp);
}

Myself.prototype.loadEnd = function(lp, e) {
	if (this.onLoadEnd)
		this.cb(this.onLoadEnd, lp, e);
}

Myself.prototype.getUsers = function(query, callback) {
	var $=this;
	$.readSimple("User"+queryString(query), 'user', function(e, resp){
		if (!e){
			$.cb(callback, resp);
		}
	});
}

// Most requests will be done through the chain endpoint with Myself.read
// However, if you want to use another endpoint (or if the request can't be chained (ex: /user/me)
// you can use this function, as long as
// the response is always an array of objects of the specified type
Myself.prototype.readSimple = function(url, type, callback) {
	var $=this;
	$.request(url, 'GET', function(e, resp) {
		if (!e) {
			var obj = {};
			resp instanceof Array || (resp = [resp]);
			obj[type] = resp;
			$.handle(e, obj);
			$.cb(callback, e, resp);
		} else {
			$.cb(callback, e, resp);
		}
	});
}

Myself.prototype.read = function(requests, filters, callback, cancel) {
	var $=this;
	var query = {};
	query.requests = requests.map(function(req) {
		if (typeof req == 'string') {
			return req;
		} else {
			var type = Object.keys(req)[0];
			return type+"-"+JSON.stringify(req[type]);
		}
	});
	for (var filter in filters)
		query[filter] = filters[filter];
	var needCategorys = !$.categoryTree && query.requests.length<5;
	if (needCategorys) {
		query.requests.push('category');
	}
	
	$.request("Read/chain"+queryString(query), 'GET', function(e, resp) {
		if (needCategorys) {
			$.categoryTree = buildCategoryTree(resp.category);
		}
		$.handle(e, resp);
		$.cb(callback, e, resp);
	}, undefined, cancel);
};

Myself.prototype.listen = function(requests, filters, callback, cancel) {
	var $=this;
	var query = {};
	
	requests.forEach(function(req) {
		var type = Object.keys(req)[0];
		query[type]=JSON.stringify(req[type]);
	});
	for (var filter in filters)
		query[filter] = filters[filter];
	
	$.request("Read/listen"+queryString(query), 'GET', function(e, resp) {
		if (!e)
			$.handle(e, resp.chain);
		$.cb(callback, e, resp);
	}, undefined, cancel);
};

Myself.prototype.getUser = function(id, callback) {
	var $=this;
	$.readSimple("User"+queryString(id), 'user', function(e, resp) {
		if (!e) {
			$.cb(callback, resp[0]);
		} else {
			$.cb(callback, null);
		}
	});
}

Myself.prototype.handle = function(e, resp) {
	var $=this;
	if (e)
		return;
	// form user id map and generate user avatar urls
	var userMap = {};
	resp.user && resp.user.forEach(function(user) {
		if (user.avatar && user.avatar != 125) {
			user.avatarURL = $.server+"/File/raw/"+user.avatar+"?size=120&crop=true";
			user.bigAvatarURL = $.server+"/File/raw/"+user.avatar+"?size=400&crop=true";
			user.rawAvatarURL = $.server+"/File/raw/"+user.avatar;
		} else {
			user.avatarURL = user.bigAvatarURL = user.rawAvatarURL = "./avatar.png";
		}
		var uid = user.id;
		if (uid) {
			if (uid == $.uid)
				$.me = user;
			userMap[uid] = user;
			$.userCache[uid] = user;
			
			if ($.userRequests[uid]) {
				$.userRequests[uid].forEach(function(func) {
					$.cb(func, user);
				});
				$.userRequests[uid] = undefined;
			}
		}
	});
	resp.userMap = userMap;
	// parse dates
	// (TODO)
}

////////////////////

Myself.prototype.logOut = function(soft) {
	if (this.auth) {
		this.auth = 'undefined'
		if (!soft) {
			localStorage.removeItem(this.lsKey);
		}
		this.emit('logout');
	}
}

// handle auth token once recieved
// also calculates your own UID (thank you random â¥)
Myself.prototype.setAuth = function(auth) {
	this.auth = auth;
	var x = JSON.parse(atob(auth.split(".")[1]));
	this.uid = +x.uid;
	this.emit('login');
}

// run callback function
// this.cb(func, args...) is the same as
// if (func) func.call(this, args...)
Myself.prototype.cb = function(func) {
	if (func)
		func.apply(this, Array.prototype.slice.call(arguments, 1));
}

// request auth token from username+password
Myself.prototype.logIn = function(username, password, callback) {
	var $=this;
	$.request("User/authenticate", 'POST', function(e, resp) {
		if (!e) {
			$.setAuth(resp);
			localStorage.setItem($.lsKey, resp);
			$.readSimple("User/me", 'user', callback);
		}
		$.cb(callback, e, resp);
	}, {username: username, password: password});
}

// try to log in with cached auth token
// if cached token is found,
//  the function returns true and tests the token by requesting api/User/me
//  and `callback` will be called once this test is finished
// if there's no cached token, it returns false and DOES NOT CALL `callback`
Myself.prototype.loadCachedAuth = function(callback) {
	var $=this;
	var cached = localStorage.getItem($.lsKey);
	if (cached) {
		$.setAuth(cached);
		$.readSimple("User/me", 'user', function(e, resp){
			if (e == 'auth' || e == 'error') {
				$.logOut(); //auth was invalid
			}
			$.cb(callback, e, resp);
		}); //this is used to test the auth
		return true;
	}
	return false;
}

Myself.prototype.getPage = function(id, callback) {
	var $=this;
	id = +id;
	$.read([
		{content: {ids: [id]}},
		{comment: {parentIds: [id], limit: 50}},
		"user.0createUserId.0editUserId.1createUserId.1editUserId",
	], {
		user: "id,username,avatar"
	}, function(e, resp) {
		if (!e) {
			var page = resp.content[0];
			if (page)
				$.cb(callback, page, resp.userMap, resp.comment);
			else
				$.cb(callback, null, {}, []);
		}
	});
}

Myself.prototype.getDiscussion = function(id, callback) {
	var $=this;
	id = +id;
	$.read([
		{content: {ids: [id]}},
		{comment: {parentIds: [id], limit: 30, reverse: true}},
		"user.0createUserId.0editUserId.1createUserId.1editUserId",
	], {
		user: "id,username,avatar"
	}, function(e, resp) {
		if (!e) {
			var page = resp.content[0];
			if (page)
				$.cb(callback, page, resp.comment.reverse(), resp.userMap);
			else
				$.cb(callback, null, [], {});
		}
	});
}

// This runs a callback when a user object is available
// it doesn't do any requests itself, so you need to do that separately before or after
Myself.prototype.whenUser = function(id, callback) {
	if (this.userCache[id]) {
		this.cb(callback, this.userCache[id]);
	} else if (this.userRequests[id]) {
		this.userRequests[id].push(callback);
	} else {
		this.userRequests[id] = [callback];
	}
}

Myself.prototype.getCategories = function(callback) {
	var $=this;
	$.read([
		'category'
	], {
		category: "id,name,description,parentId"
	}, function(e, resp) {
		if (!e) {
			var tree = buildCategoryTree(resp.category);
			$.cb(callback, tree);
		}
	});
}

var rootCategory = {
	name: "[root]",
	id: 0,
}

// get the pages in a category
Myself.prototype.getCategory = function(id, count, start, sort, reverse, callback) {
	id=+id;
	var $=this;
	var search = {
		parentIds: [id],
		limit: +count,
	}
	if (start)
		search.skip = +start;
	if (sort)
		search.sort = sort;
	if (reverse)
		search.reverse = reverse;
	if (id)
		var childCategorysFilter = {parentIds: [id]};
	else
		childCategorysFilter = {};
	$.read([
		{content: search},
		{category: {ids: [id]}},
		{category: childCategorysFilter},
		"user.0createUserId"
	], {
		content: "id,name,parentId,createUserId,editDate",
		category: "id,name,description,parentId",
		user: "id,username,avatar"
	}, function(e, resp) {
		if (!e) {
			var category;
			var childs = [];
			resp.category.forEach(function(cat) {
				if (cat.parentId == id)
					childs.push(cat);
				if (cat.id == id)
					category = cat;
			});
			if (id==0) {
				$.cb(callback, rootCategory, childs, resp.content, resp.userMap);
			} else if (category)
				$.cb(callback, category, childs, resp.content, resp.userMap);
			else
				$.cb(callback, null, childs, resp.content, resp.userMap);
		}
	});
}

Myself.prototype.getPageForEditing = function(id, callback) {
	var $=this;
	if (id) {
		id = +id;
		$.read([
			{content: {ids: [id]}},
			"user.0createUserId.0editUserId",
		], {
			user: "id,username,avatar"
		}, function(e, resp) {
			if (!e) {
				var page = resp.content[0];
				if (page)
					$.cb(callback, page, resp.userMap);
				else
					$.cb(callback, null, {});
			}
		});
	} else {
		if ($.categoryTree) {
			$.cb(callback, null, {});
		} else {
			this.readSimple("Category", 'category', function(e, resp) {
				$.categoryTree = buildCategoryTree(resp);
				$.cb(callback, null, {});
			});
		}
	}
}

Myself.prototype.listenChat = function(ids, firstId, lastId, listeners, callback, cancel) {
	var $=this;
	if (lastId == -Infinity)
		lastId = undefined;
	$.listen([
		{actions: {
			parentIds: ids,
			lastId: lastId,
			chain: ["comment.0id","user.1createUserId"]
		}},
	], {
		user: "id,username,avatar"
	}, function(e, resp) {
		if (e)
			$.cb(callback, e, resp);
		else {
			$.cb(callback, e, resp.chain.comment, resp.listeners, resp.chain.userMap);
		}
	}, cancel);
}

Myself.prototype.postPage = function(page, callback) {
	if (page.id) {
		this.request("Content/"+page.id, 'PUT', callback, page);
	} else {
		this.request("Content", 'POST', callback, page);
	}
}

Myself.prototype.deletePage = function(id, callback) {
	this.request("Content/"+id+"/delete", 'POST', callback);
}

Myself.prototype.postComment = function(id, message, markup, callback) {
	this.request("Comment", 'POST', callback, {
		parentId: id,
		content: JSON.stringify({t: message, m: markup})
	});
};

Myself.prototype.setWatch = function(id, state, callback) {
	if (state)
		this.request("Watch/"+id, 'POST', callback);
	else
		this.request("Watch/"+id+"/delete", 'POST', callback);
};

Myself.prototype.getWatch = function(query, callback) {
	this.request("Watch"+queryString(query), 'GET', callback);
}

Myself.prototype.setVote = function(id, state, callback) {
	this.request("Vote/"+id+"/"+(state||"delete"), 'POST', callback);
}

Myself.prototype.getVote = function(query, callback) {
	this.request("Vote"+queryString(query), 'GET', callback);
}

Myself.prototype.register = function(username, password, email, callback) {
	this.request("User/register", 'POST', callback, {
		username: username,
		password: password,
		email: email
	});
}

Myself.prototype.sendEmail = function(email, callback) {
	this.request("User/register/sendemail", 'POST', callback, {
		email: email
	});
}

Myself.prototype.confirmRegister = function(key, callback) {
	var $=this;
	$.request("User/register/confirm", 'POST', function(e, resp) {
		if (!e) {
			$.setAuth(resp);
			localStorage.setItem($.lsKey, resp);
			$.readSimple("User/me", 'user', function(){});
		}
		$.cb(callback, e, resp);
	}, {
		confirmationKey: key
	});
}

Myself.prototype.getSettings = function(callback) {
	var $=this;
	if (me.auth) {
		$.read([
			{user: {ids: [$.uid]}},
			{content: {createUserIds: [$.uid], type: '@user.page', limit: 1}},
		], {
			content: "id"
		}, function(e, resp) {
			if (!e && resp.user && resp.user[0]) {
				$.cb(callback, resp.user[0], resp.content[0]);
			} else {
				$.cb(callback, null, null);
			}
		});
	} else {
		$.cb(callback, null);
	}
}

Myself.prototype.uploadFile = function(data, callback) {
	this.request("File", 'POST', callback, data);
}

Myself.prototype.setBasic = function(data, callback) {
	this.request("User/basic", 'PUT', callback, data);
}

Myself.prototype.getActivity = function(callback) {
	var $=this;
	$.read([
		//todo: this should just get an entire day??
		// except no that won't work if site dies lol
		{activity: {limit: 20, reverse: true}},
		{commentaggregate: {limit: 100, reverse: true}},
		"content.0contentId.1id",
		"user.0userId.1userIds"
	], {
		content: "name,id"
	},function(e, resp) {
		if (!e) {
			$.cb(callback, resp.activity, resp.commentaggregate, resp.content, resp.userMap)
		} else {
			$.cb(callback, null, null, null, {});
		}
	});
}

Myself.prototype.getUserPage = function(id, callback) {
	var $=this;
	id = +id;
	$.read([
		{user: {userIds: [id]}},
		{content: {createUserIds: [id], type: '@user.page', limit: 1}}, //page
		{activity: {userIds: [id], limit: 20, reverse: true}},
		{commentaggregate: {userIds: [id], limit: 100, reverse: true}},
		"content.2contentId.3id"
	], {
	}, function(e, resp) {
		if (!e) {
			console.log("user page",resp);
			var user = resp.userMap[id];
			// ugh need to make
			// content map now
			// to map Content to Activity
			// you know, maybe this could be done automatically.... somehow
			if (user) {
				var page = resp.content[0];
				if (page && page.type != "@user.page")
					page = undefined;
				$.cb(callback, user, page, resp.activity, resp.commentaggregate, resp.content, resp.userMap);
			} else
				$.cb(callback, null, {}, [], [], [], {});
		}
	});
	// what we need:
	// user object
	// user page
	// recent activity + assoc contentz
	// recent comment aggregate + assoc contentz
}

function buildCategoryTree(categories) {
	var root = {childs: [], id: 0, name: "[root]"};
	var orphans = [];
	var map = {
		'0': root
	};
	root.map = map;
	categories.forEach(function(cat) {
		cat.childs = [];
		map[cat.id] = cat;
	});
	categories.forEach(function(cat) {
		//cat = Object.assign({}, cat); //copy
		if (cat.parentId < 0)
			cat.parentId = 0;
		var parent = map[cat.parentId];
		if (parent) {
			cat.parent = parent;
			parent.childs.push(cat);
		} else {
			orphans.push(cat);
		}
	});
	return root;
}
function DiscussionLongPoller(myself, callback) {
	this.myself = myself;
	
	this.firstId = 0; // minimum id for all rooms
	this.lastId = 0; // max comment id for all rooms

	this.idList = []; // list of discussion ids
	
	this.firstIds = {}; //first id per room
	this.lastIds = {}; //last id per room
	this.listeners = {}; //userlist per room
	
	this.cancel = [function(){}];
	this.callback = callback;
}

// ok so what this needs to do is
// 1: get info for the new room (room page contents, listeners, comments)
// 2: cancel the current longpoll
// 3: start a new longpoll with the updated info
DiscussionLongPoller.prototype.addRoom = function(id) {
	if (this.lastIds[id])
		return;
	var $=this;
	// todo: this doesn't get the listners
	// what we can do is maybe,
	// make 2 requests (one for listeners, the other for page contents)
	// and then when they BOTH finish, reload the long poller
	$.myself.getDiscussion(id, function(page, comments, userMap) {
		if (page) {
			$.callback.call($, comments, null, userMap, page);
			$.cancel[0]();
			$.listeners[id] = [0];
			if (comments.length) {
				$.firstIds[id] = comments[0].id;
				$.lastIds[id] = comments[comments.length-1].id;
			}
			$.updateIdRange();
			$.idList.push(id);
			$.running = true;
			$.loop();
		} else {
			$.callback.call($, null, null, null, false);
		}
	})
}

DiscussionLongPoller.prototype.updateIdRange = function() {
	this.firstId = Infinity;
	this.lastId = -Infinity;
	for (id in this.lastIds) {
		if (this.firstIds[id] < this.firstId)
			this.firstId = this.firstIds[id];
		if (this.lastIds[id] > this.lastId)
			this.lastId = this.lastIds[id];
	}
}

DiscussionLongPoller.prototype.reset = function() {
	this.stop();
	this.firstId = 0;
	this.lastId = 0;

	this.idList = [];
	
	this.firstIds = {};
	this.lastIds = {};
	this.listeners = {};
	
	this.cancel = [function(){}];
}

DiscussionLongPoller.prototype.removeRoom = function(id) {
	if (this.lastIds[id]) {
		// stop long poller
		this.cancel[0]();
		// remove info for current room
		delete this.listeners[id];
		delete this.firstIds[id];
		delete this.lastIds[id];
		var i = this.idList.indexOf(id);
		if (i >= 0)
			this.idList.splice(i, 1);
		// update first and last ids
		this.updateIdRange();
		// start long poller again
		this.loop();
	}
}

DiscussionLongPoller.prototype.stop = function() {
	this.running = false;
	this.cancel[0]();
}

DiscussionLongPoller.prototype.loop = function() {
	var $=this;
	$.myself.listenChat($.idList, $.firstId, $.lastId, $.listeners, function(e, comments, listeners, userMap){
		if (!e) {
			comments = comments || [];
			comments.forEach(function(comment) {
				if (comment.id > $.lastIds[comment.parentId]) {
					$.lastIds[comment.parentId] = comment.id;
				}
			});
			$.updateIdRange();
			$.listeners = listeners || {};
			$.callback.call($, comments, listeners, userMap, null);
		}
		if (!e || e=='timeout') {
			$.running = true;
			var t = setTimeout(function() {
				$.loop();
			}, 0);
			$.cancel = [function() {
				clearTimeout(t);
			}]
		} else {
			$.running = false;
			alert("LONG POLLER FAILED");
			console.error("LONG POLLER FAILED");
		}
	}, $.cancel);
}
var highlight_smilebasic = (function(){
	//keywords that don't have an expression after them
	var keywords=[
		"BREAK","COMMON","CONTINUE","ELSE","END","ENDIF","REM","REPEAT","THEN","WEND",
	];
	var keywords_sb3=[
		"STOP"	
	];
	var keywords_sb4=[
		"OTHERWISE","ENDCASE","LOOP","ENDLOOP"
	];
	//keywords w/ expression after them (or other special thing)
	var argKeywords=[
		"CALL","DATA","DEC","DIM","ELSEIF","EXEC","FOR","GOSUB","GOTO","IF","INC","INPUT","LINPUT","NEXT","ON","OUT","PRINT","READ","RESTORE","RETURN","SWAP","UNTIL","USE","VAR","WHILE",
	];
	var argKeywords_sb4=[
		"CASE","WHEN","DEFOUT","TPRINT","CONST","ENUM",
	];
	var builtinFunctions=[
		"ABS","ACCEL","ACLS","ACOS","ARYOP","ASC","ASIN","ATAN","ATTR","BACKCOLOR","BEEP","BGMCHK","BGMCLEAR","BGMCONT","BGMPAUSE","BGMPLAY","BGMSET","BGMSETD","BGMSTOP","BGMVAR","BGMVOL","BIN$","BIQUAD","BQPARAM","BREPEAT","BUTTON","CEIL","CHKCALL","CHKCHR","CHKFILE","CHKLABEL","CHKMML","CHKVAR","CHR$","CLASSIFY","CLIPBOARD","CLS","COLOR","CONTROLLER","COPY","COS","COSH","DEG","DELETE","DIALOG","DTREAD","EFCSET","EFCWET","EXP","FADE","FADECHK","FFT","FFTWFN","FILES","FILL","FLOOR","FORMAT$","GBOX","GCIRCLE","GCLIP","GCLS","GCOLOR","GCOPY","GFILL","GLINE","GLOAD","GPAINT","GPSET","GPUTCHR","GSAVE","GTRI","GYROA","GYROSYNC","GYROV","HEX$","IFFT","INKEY$","INSTR","KEY","LEFT$","LEN","LOAD","LOCATE","LOG","MAX","MID$","MIN","OPTION","PCMCONT","PCMSTOP","PCMSTREAM","PCMVOL","POP","POW","PRGDEL","PRGEDIT","PRGGET$","PRGINS","PRGNAME$","PRGSET","PRGSIZE","PROJECT","PUSH","RAD","RANDOMIZE","RENAME","RGB","RIGHT$","RINGCOPY","RND","RNDF","ROUND","RSORT","SAVE","SCROLL","SGN","SHIFT","SIN","SINH","SNDSTOP","SORT","SPANIM","SPCHK","SPCHR","SPCLR","SPCOL","SPCOLOR","SPCOLVEC","SPDEF","SPFUNC","SPHIDE","SPHITINFO","SPHITRC","SPHITSP","SPHOME","SPLINK","SPOFS","SPPAGE","SPROT","SPSCALE","SPSET","SPSHOW","SPSTART","SPSTOP","SPUNLINK","SPUSED","SPVAR","SQR","STICK","STR$","SUBST$","TALK","TALKCHK","TALKSTOP","TAN","TANH","TMREAD","TOUCH","UNSHIFT","VAL","VSYNC","WAIT","WAVSET","WAVSETA","XSCREEN",
		//BIG+SB4
		"VIBRATE",
	];
	var builtinFunctions_sb3=[
		"BACKTRACE","BGANIM","BGCHK","BGCLIP","BGCLR","BGCOLOR","BGCOORD","BGCOPY","BGFILL","BGFUNC","BGGET","BGHIDE","BGHOME","BGLOAD","BGOFS","BGPAGE","BGPUT","BGROT","BGSAVE","BGSCALE","BGSCREEN","BGSHOW","BGSTART","BGSTOP","BGVAR","BGMPRG","BGMPRGA","DISPLAY","DLCOPEN","EFCOFF","EFCON","FONTDEF","GOFS","GPAGE","GPRIO","GSPOIT","MICDATA","MICSAVE","MICSTART","MICSTOP","MPEND","MPGET","MPNAME$","MPRECV","MPSEND","MPSET","MPSTART","MPSTAT","STICKEX","RGBREAD","SPCLIP","VISIBLE","WIDTH","XOFF","XON",
		//BIG
		"GPUTCHR16",
	];
	var builtinFunctions_sb4=[
		"PCMPOS","TYPEOF","ARRAY#","ARRAY%","ARRAY$","RESIZE","INSERT","REMOVE","INSPECT","DEFARGC","DEFARG","DEFOUTC","INT","FLOAT","LAST","FONTINFO","PERFBEGIN","PERFEND","SYSPARAM","METAEDIT","METALOAD","METASAVE","XCTRLSTYLE","MOUSE","MBUTTON","IRSTART","IRSTOP","IRSTATE","IRREAD","IRSPRITE","KEYBOARD","TCPIANO","TCHOUSE","TCROBOT","TCFISHING","TCBIKE","TCVISOR","LOADG","LOADV","SAVEG","SAVEV","ANIMDEF","TSCREEN","TPAGE","TCOLOR","TLAYER","TPUT","TFILL","THOME","TOFS","TROT","TSCALE","TSHOW","THIDE","TBLEND","TANIM","TSTOP","TSTART","TCHK","TVAR","TCOPY","TSAVE","TLOAD","TARRAY","TUPDATE","TFUNC","GTARGET","RGBF","HSV","GPGET","GARRAY","GUPDATE","GSAMPLE","SPLAYER","STOP","LAYER","LMATRIX","LFILTER","LCLIP","BEEPPIT","BEEPPAN","BEEPVOL","BEEPSTOP","BGMPITCH","BGMWET","EFCEN","SNDMSBAL","SNDMVOL","PRGSEEK","XSUBSCREEN","ENVSTAT","ENVTYPE","ENVLOAD","ENVSAVE","ENVINPUT$","ENVFOCUS","ENVPROJECT","ENVLOCATE","PUSHKEY","HELPGET","HELPINFO","UISTATE","UIMASK","UIPUSHCMPL","DATE$","TIME$","RESULT","CALLIDX","FREEMEM","MILLISEC","MAINCNT",
	];
	//SB3 only
	var systemVariables=["CALLIDX","CSRX","CSRY","CSRZ","DATE$","ERRLINE","ERRNUM","ERRPRG","EXTFEATURE","FREEMEM","HARDWARE","MAINCNT","MICPOS","MICSIZE","MILLISEC","MPCOUNT","MPHOST","MPLOCAL","PCMPOS","PRGSLOT","RESULT","SYSBEEP","TABSTEP","VERSION"];
	
	function isAlpha(c){
		return c>='A'&&c<='Z'||c>='a'&&c<='z';
	}
	
	function isDigit(c){
		return c>='0'&&c<='9';
	}
	
	//token types:
	//"linebreak"  - line break
	//"function"   - function call
	//"operator"   - operators, including word operators
	//"name"       - function name (after DEF keyword)
	//"equals"     - = assignment operator
	//"expr"       - ; or , or ( or [
	//"noexpr"     - : or ) or ]
	//"whitespace" - space or tab
	//"variable"   - variable
	//"number"     - number literal (including TRUE/FALSE)
	//"def"        - DEF keyword
	//"string"     - strings (including label strings)
	//"word"       - unknown word (resolved to "function", "operator", "name", "variable", "def", "argkeyword", or "keyword")
	//"label"      - unknown label/labelstring (resolved to "label" or "string"), or label (not label string)
	//"argkeyword" - keyword with expression after it
	//"keyword"    - keyword that doesn't have an expression after it
	
	function isInExpr(type){
		return type=="argkeyword"||type=="function"||type=="operator"||type=="name"||type=="equals"||type=="expr";
	}
	
	return function(code, callback, sb4){
		var i=-1,c;
		function next(){
			i++;
			c=code.charAt(i);
		}

		function jump(pos){
			i=pos-1;
			next();
		}
		
		var prev=0;
		var prevType="start";
		
		//=================//
		// Process a token //
		//=================//
		function push(type, cssType){
			var word=code.substring(prev,i);
			prev=i;
			//Check words
			if(type=="word"){
				var upper=word.toUpperCase();
				//True/False
				if(sb4!=true && (upper=="TRUE"||upper=="FALSE")){
					type="number";
					cssType="true-false number";
				//operators
				}else if(upper=="DIV"||upper=="MOD"||upper=="AND"||upper=="OR"||upper=="XOR"||upper=="NOT"){
					type="operator";
					cssType="word-operator operator";
				//DEF
				}else if(upper=="DEF"){
					type="def";
					cssType="def keyword";
				//T? TPRINT
				}else if(sb4!=false && (upper=="T" && c=='?')){
					word+=c;
					next();
					prev=i;
					type="keyword";
					cssType="keyword";
				//keywords without an expression after them
				}else if(keywords.indexOf(upper)>=0 || sb4==false && keywords_sb3.indexOf(upper)>=0 || sb4!=false && keywords_sb4.indexOf(upper)>=0){
					type="keyword";
					cssType="keyword";
				//keywords w/ and expression after
				}else if(argKeywords.indexOf(upper)>=0 || sb4!=false && argKeywords_sb4.indexOf(upper)>=0){
					type="argkeyword";
					cssType="keyword";
				//User-defined function name
				}else if(prevType=="def"){
					type="name";
					cssType="name";
				//Variable, function, TO/STEP, etc.
				}else{
					var fPos=i;
					while(c==' ' || c=='\t')
						next();
					var isFunc=false;
					if(isInExpr(prevType)){
						if(c=="(")
							isFunc=true;
					}else{
						isFunc=true;
						if(c=="["){
							isFunc=false;
						}else if(c=="="){
							next();
							if(c!="=")
								isFunc=false;
						}
					}
					if(isFunc){
						type="function";
						if(builtinFunctions.indexOf(upper)!=-1 || sb4!=true && builtinFunctions_sb3.indexOf(upper)!=-1 || sb4!=false && builtinFunctions_sb4.indexOf(upper)!=-1)
							cssType="statement function";
						else if(upper=="TO" || upper=="STEP")
							cssType="to-step keyword";
						else
							cssType="statement";
					}else{
						type="variable"
						if(sb4!=true && systemVariables.indexOf(upper)!=-1)
							cssType="variable function";
						else
							cssType="variable";
					}
					jump(fPos);
				}
			//Check labels
			}else if(type=="label"){
				if(isInExpr(prevType)){
					type="string";
					cssType="label-string string";
				}else{
					cssType="label";
				}
			//Use type as csstype if not specified
			}else{
				if(cssType==undefined)
					cssType=type;
			}
			//pass to callback function
			callback(word,cssType);
			//store previous non-whitespace token type
			if(type!="whitespace")
				prevType=type;
		}
		
		next();
		
		//loop until the end of the string
		while(c){
			//
			//keywords, functions, variables
			//
			if(isAlpha(c)||c=='_'){
				next();
				//read name
				while(isAlpha(c)||isDigit(c)||c=='_')
					next();
				//read type suffix
				if(c=='#'||c=='%'||c=='$')
					next();
				//push word type
				push("word");
			//
			//numbers
			//
			}else if(isDigit(c)||c=='.'){
				//if digit was found, read all of them
				while(isDigit(c))
					next();
				//if there's a decimal point
				if(c=='.'){
					next();
					//read digits after
					if(isDigit(c)){
						next();
						while(isDigit(c))
							next();
					}else{
						//if GOTO is available: GOTO @skip_e
						if(c=='#')
							next();
						push("number");
						continue;
					}
				}
				//E notation
				if(c=='E'||c=='e'){
					var ePos=i;
					next();
					//check for + or -
					if(c=='+'||c=='-')
						next();
					//read digits
					if(isDigit(c)){
						next();
						while(isDigit(c))
							next();
					//no digits (invalid)
					}else{
						jump(ePos);
						push();
						continue;
					}
				}
				//(if GOTO is available: @skip_e)
				//read float suffix
				if(c=='#')
					next();
				push("number");
			//
			//strings
			//
			}else switch(c){
			case '"':
				next();
				//read characters until another quote, line ending, or end of input
				while(c && c!='"' && c!='\n' && c!='\r')
					next();
				//read closing quote
				if(c=='"')
					next();
				push("string");
			//
			//comments
			//
			break;case '\'':
				next();
				//read characters until line ending or end of input
				while(c && c!='\n' && c!='\r')
					next();
				push("comment");
			//
			//logical AND, hexadecimal, binary
			//
			break;case '&':
				next();
				switch(c){
				//logical and
				case '&':
					next();
					push("operator");
				//hexadecimal
				break;case 'H':case 'h':
					var hPos=i;
					next();
					//read hexadecimal digits
					if(isDigit(c)||c>='A'&&c<='F'||c>='a'&&c<='f'|| (c=='_'&&sb4!=false)){
						next();
						while(isDigit(c)||c>='A'&&c<='F'||c>='a'&&c<='f'|| (c=='_'&&sb4!=false))
							next();
						push("number");
					}else{
						jump(hPos);
						push();
					}
				//binary
				break;case 'B':case 'b':
					var bPos=i;
					next();
					//read hexadecimal digits
					if(c=='0'||c=='1'|| (c=='_'&&sb4!=false)){
						next();
						while(c=='0'||c=='1'|| (c=='_'&&sb4!=false))
							next();
						push("number");
					}else{
						jump(bPos);
						push();
					}
				//invalid &
				break;default:
					push();
				}
			//
			//labels
			//
			break;case '@':
				next();
				//read name
				while(isDigit(c)||isAlpha(c)||c=='_')
					next();
				//ok
				push("label");
			//
			//constants
			//
			break;case '#':
				next();
				//read name
				if(isDigit(c)||isAlpha(c)||c=='_'){
					next();
					while(isDigit(c)||isAlpha(c)||c=='_')
						next();
					//read type suffix
					if(c=='#'||c=='%'||c=='$')
						next();
					push("number","constant number");
				}else{
					//read type suffix
					if(c=='#'||c=='%'||c=='$'){
						next();
						push("number","constant number");
					}else{
						push();
					}
				}
			//
			//logical or
			//
			break;case '|':
				next();
				//logical or
				if(c=='|'){
					next();
					push("operator");
				//invalid
				}else{
					push();
				}
			//
			//less than, less than or equal, left shift
			//
			break;case '<':
				next();
				if(c=='='||c=='<') //<= <<
					next();
				push("operator");
			//
			//greater than, greater than or equal, right shift
			//
			break;case '>':
				next();
				if(c=='='||c=='>') //>= >>
					next();
				push("operator");
			//
			//equal, equal more
			//
			break;case '=':
				next();
				//==
				if(c=='='){
					next();
					push("operator");
				}else{
					push("equals");
				}
			//
			//logical not, not equal
			//
			break;case '!':
				next();
				if(c=='=') // !=
					next();
				push("operator");
			//
			//add, subtract, multiply, divide
			//
			break;case '+':case '-':case '*':case '/':
				next();
				push("operator");
			//
			// Line continuation (SB4)
			//
			break;case '\\':
				next();
				if (sb4==false) {
					push(undefined,false);
				} else {
					while (c && c!='\n' && c!='\r')
						next();
					next();
					push("whitespace")
				}
			
			//
			//other
			//
			
			break;case ';':case ',':case '[':case '(':
				next();
				push("expr",false);
			break;case '\n':
				next();
				push("linebreak",false);
			break;case ":":case ")":case "]":
				next();
				push("noexpr",false);
			break;case " ":case "\t":
				next();
				push("whitespace",false);
			break;case '?':
				next();
				push("argkeyword","question keyword");
			break;default:
				next();
				push(undefined,false);
			}
		}
		push("eof");
	}
})();

function highlightSB(text, lang) {
	function escapeHTML(text) {
		return text.replace(/&/g,"&amp;").replace(/</g,"&lt;");
	}
	
	if (lang)
		lang = lang.toLowerCase();
	
	var html="";
	
	if (!lang || lang == "sb3" || lang == "sb4" || lang == "sb") {
		if (lang == "sb4")
			lang = true;
		else if (lang == "sb3")
			lang = false;
		else
			lang = undefined;
		
		var prevType=false;
		//this is called for each highlightable token
		function callback(word, type) {
			if (word) {
				//only make a new span if the CSS class has changed
				if (type!=prevType) {
					//close previous span
					if (prevType)
						html += "</span>";
					//open new span
					if (type)
						html += "<span class=\""+type+"\">";
				}
				html += escapeHTML(word);
				prevType = type;
			}
		}
		
		highlight_smilebasic(text, callback, lang);
		//close last span
		if (prevType)
			html += "</span>";
	} else {
		html = escapeHTML(text);
	}
	
	return html;
}
var Parse = {
	lang:{}
};

var create = function(x) {
	return document.createElement(x);
}
var createText = function(x) {
	return document.createTextNode(x);
}
var creator = function (tag) {
	return function() {
		return create(tag);
	}
};

Parse.options = {
	append: function (parent, child) {
		parent.appendChild(child);
	},
	parent: function (child) { // unused currently
		return child.parent;
	},
	remove: function(child) {
		child.parentNode.removeChild(child);
	},

	preview: {
		video: function(url) {
			
		},
		youtube: function(url) {
			
		},
		audio: function(url) {
			
		}
	},
	
	//========================
	// nodes without children:
	text: function(text) {
		return createText(text);
	},
	lineBreak: creator('br'),
	line: creator('hr'),
	// code block
	code: function(code, language) {
		var node = create('pre');
		node.setAttribute('data-lang', language);
		node.innerHTML = highlightSB(code, language);
		return node;
	},
	// inline code
	icode: function(code) {
		var node = create('code');
		node.textContent = code;
		return node;
	},
	audio: function(url, preview) {
		if (preview) {
			var node = create('div');
			node.className = "audioPreview preview";
			node.textContent = "[audio preview]\n";
			return node;
		}
		var node = create('audio');
		node.setAttribute('controls', "");
		node.setAttribute('src', url);
		return node;
	},
	video: function(url, preview) {
		if (preview) {
			var node = create('div');
			node.className = "videoPreview preview";
			node.textContent = "[video preview]\n";
			return node;
		}
		var node = create('video');
		node.setAttribute('controls', "");
		node.setAttribute('src', url);
		return node;
	},
	youtube: function(url, preview) {
		var protocol = "https:";
		if (window.location && window.location.protocol == "http:")
			protocol = "http:"
		var match = url.match(/(?:https?:\/\/)?(?:www\.)?youtu\.?be(?:\.com)?\/?.*(?:watch|embed)?(?:.*v=|v\/|\/)([\w\-_]+)\&?/);
		
		if (true) {
			var node = create('img');
			node.className = "youtube";
			if (match)
				node.src = protocol+"//i.ytimg.com/vi/"+match[1]+"/mqdefault.jpg";
			return node;
		}
		var node = create('iframe');
		node.className = "youtube";
		if (match)
			node.src = protocol+"//www.youtube-nocookie.com/embed/"+match[1];
		return node;
	},
	
	//=====================
	// nodes with children
	root: function() {
		var node = create('div');
		node.className = "markup-root";
		return node;
	},
	bold: creator('b'),
	italic: creator('i'),
	underline: creator('u'),
	strikethrough: creator('s'),
	heading: function(level) { // input: 1, 2, or 3
		return create('h' + (level+1));//['h1','h2','h3'][level-1] || 'h3');
	},
	quote: function(user) {
		var node = create('blockquote');
		node.setAttribute('cite', user);
		return node;
	},
	list: creator('ul'),
	item: creator('li'), // (list item)
	link: function(url) {
		// important, do not remove, prevents script injection
		if (/^ *javascript:/i.test(url))
			url = "";
		
		var protocol = url.match(/^([-\w]+:)([^]*)$/);
		if (protocol && protocol[1].toLowerCase() == "sbs:") {
			// put your custom local url handling code here
			url = "#"+protocol[2];
			
		} else if (!protocol) {
			// urls without protocol get https:// or http:// added
			var protocol = "https:";
			if (window.location && window.location.protocol == "http:")
				protocol = "http:";
			url = protocol+"//"+url;
		}
		
		var node = create('a');
		node.setAttribute('href', url);
		return node;
	},
	table: creator('table'),
	row: creator('tr'),
	cell: function (header) {
		return header ?
			create('th') :
			create('td');
	},
	image: function(url) {
		var node = create('img');
		node.setAttribute('src', url);
		node.setAttribute('tabindex', "-1");
		return node;
	},
	error: function() {
		var node = create('div');
		node.className = "parse-error";
		node.textContent = "Error";
		return node;
	},
	align: function(arg) {
		var node = create('div');
		if (arg == 'left' || arg == 'right' || arg == 'center')
			node.style.textAlign = arg;
		return node;
	},
	sup: creator('sup'),
	sub: creator('sub'),
	anchor: function(name) {
		var node = create('a');
		node.name = "_anchor_"+name;
		return node;
	}
}

Parse.lang['12y'] = function(code, preview, cache) {
	// so what happens here is
	// when a video needs to be generated
	// first, check the cache. if it exists there, insert it
	// (remember that a node can only exist in one place in the DOM though)
	// now, if the video needs to be created, and preview mode is enabled,
	// a place holder is generated (and not stored in the cache)
	// if preview is disabled (and cache is passed), the video is generated
	// and stored in the cache, to be reused later
	
	// in the editor, this should be called normally with preview mode enabled
	// then maybe after a delay of no typing, call it with preview off,
	// to generate any new videos
	// or don't use preview at all! maybe it's fine!
	if (cache)
		markCacheUnused();
	
	var options = Parse.options;
	var output = options.root();
	var curr = output;
	var lastLineBreak = null;
	var displayBlock = {
		code:true,audio:true,video:true,heading:true,quote:true,
		list:true,item:true,table:true,image:true,line:true,youtube:true,
	};
	var skipNextLineBreak;
	
	try {
		// this is a list of all nodes that we are currently inside
		// as well as {}-block pseudo-nodes
		var stack = [{node:curr, type:'root'}];
		stack.top = function() {
			return stack[stack.length-1];
		};
		var textBuffer = "";
		var inside = {};
		var startOfLine = true;
		var leadingSpaces = 0;
		var lastWasBlock;
		// todo:
		// so, the way to prevent extra linebreaks (without just ignoring them all) is
		// to ignore linebreaks around blocks. (before and after, as well as inside, ignore 1 leading/trailing linebreak)
		// idea:
		
		var i = -1;
		var c;
		scan();
		
		while (c) {
			if (eatChar("\n")) {
				endLine();
				//==========
				// \ escape
			} else if (eatChar("\\")) {
				if (c == "\n")
					addLineBreak();
				else
					addText(c);
				scan();
				//===============
				// { group start (why did I call these "groups"?)
			} else if (eatChar("{")) {
				startBlock(null, {});
				lineStart();
			//=============
			// } group end
			} else if (eatChar("}")) {
				if (stackContains(null)) {
					closeAll(false);
				} else {
					addText("}");
				}
			//================
			// * heading/bold
			} else if (c == "*") {
				if (startOfLine && (code[i+1] == "*" || code[i+1] == " ")) {
					var headingLevel = 0;
					while (eatChar("*"))
						headingLevel++;
					if (headingLevel > 3)
						headingLevel = 3;
					
					if (eatChar(" "))
						startBlock('heading', {}, headingLevel);
					else
						addMulti('*', headingLevel);
				} else {
					doMarkup('bold', options.bold);
				}
			} else if (c == "/") {
				doMarkup('italic', options.italic);
			} else if (c == "_") {
				doMarkup('underline', options.underline);
			} else if (c == "~") {
				doMarkup('strikethrough', options.strikethrough);
			//============
			// >... quote
			} else if (startOfLine && eatChar(">")) {
				// todo: maybe >text should be a quote without author... 
				// need to add a way to add information to quotes:
				// - user ID
				// - post ID
				start = i;
				while (eatChar(" "))
					;
				while (c && !char_in(c, " \n{:"))
					scan();
				var name = code.substring(start, i).trim();
				eatChar(":");
				while (eatChar(" "))
					;
				startBlock('quote', {}, name);
				//==============
				// -... list/hr
			} else if (startOfLine && eatChar("-")) {
				//----------
				// --... hr
				if (eatChar("-")) {
					var count = 2;
					while (eatChar("-"))
						count++;
					//-------------
					// ---<EOL> hr
					if (c == "\n" || !c) { //this is kind of bad
						addBlock(options.line());
						skipNextLineBreak = true; //hack
					//----------
					// ---... normal text
					} else {
						addMulti("-", count);
					}
				//------------
				// - ... list
				} else if (eatChar(" ")) {
					startBlock('list', {level:leadingSpaces});
					startBlock('item', {level:leadingSpaces});
				//---------------
				// - normal char
				} else
					addText("-");
			//==========================
			// ] end link if inside one
			} else if (c == "]" && stack.top().inBrackets){ //this might break if it assumes .top() exists. needs more testing
				scan();
				if (stack.top().big) {
					if (eatChar("]"))
						endBlock();
					else
						addText("]");
				} else
					endBlock();
			//================
			// https?:// link
			} else if (c == "h" || c == "!") { //lol this is silly
				var embed = eatChar("!");
				if (embed && eatChar("[")) {
					readBracketedLink(embed) || addText("[");
					// handled
				} else {
					var start = i;
					if (code.substr(start,7) == "http://" || code.substr(start,8) == "https://") {
						var url = readUrl();
						startBlock(embed ? urlType(url) : 'link', {}, url, preview);
						if (eatChar("["))
							stack.top().inBrackets = true;
						else {
							addText(url);
							endBlock();
						}
					} else {
						if (embed)
							addText("!");
						else {
							scan();
							addText("h");
						}
					}
				}
			//============
			// |... table
			} else if (c == "|") {
				var top = stack.top();
				// continuation
				if (top.type == 'cell') {
					var row = top.row;
					var table = top.row.table;
					scan();
					eatChar("\n");
					//--------------
					// | | next row
					if (eatChar("|")) {
						if (table.columns == null)
							table.columns = row.cells;
						endBlock();
						if (top_is('row')) //always
							endBlock();
						var row = startBlock('row', {table:table, cells:0});
						row.header = eatChar("*");
						startBlock('cell', {row:row}, row.header);
						while (eatChar(" "))
							;
						//--------------------------
						// | next cell or table end
					} else {
						row.cells++;
						textBuffer = textBuffer.replace(/ *$/,""); //strip trailing spaces (TODO: allow \<space>)
						// end of table
						// table ends when number of cells in current row = number of cells in first row
						// single-row tables are not easily possible ..
						// TODO: fix single row tables
						if (table.columns != null && row.cells > table.columns) {
							endBlock(); //end cell
							if (top_is('row')) //always
								endBlock();
							if (top_is('table')) //always
								endBlock();
						} else { // next cell
							endBlock();
							startBlock('cell', {row:row}, row.header);
							while (c == " ")
								scan();
						}
					}
					// start of new table (must be at beginning of line)
				} else if (startOfLine) {
					scan();
					table = startBlock('table', {
						columns: null
					});
					row = startBlock('row', {
						table: table,
						cells: 0
					});
					row.header = eatChar("*");
					startBlock('cell', {
						row: row
					}, row.header);
					while (eatChar(" "))
						;
				} else {
					scan();
					addText("|");
				}
				//===========
				// `... code
			} else if (eatChar("`")) {
				//---------------
				// ``...
				if (eatChar("`")) {
					//----------------
					// ``` code block
					if (eatChar("`")) {
						// read lang name
						start = i;
						while (c && c!="\n" && c!="`")
							scan();
						var language = code.substring(start, i).trim().toLowerCase();
						eatChar("\n");
						start = i;
						i = code.indexOf("```", i);
						addBlock(options.code(
							code.substring(start, i!=-1 ? i : code.length),
							language
						));
						skipNextLineBreak = true;
						if (i != -1) {
							i += 2;
							scan();
						} else {
							i = code.length;
							scan();
						}
					//------------
					// `` invalid
					} else {
						addText("``");
					}
				// --------------
				// ` inline code
				} else {
					start = i;
					var codeText = ""
					while (c) {
						if (c=="`") {
							if (code[i+1] == "`") {
								if (i == start+1 && codeText[0] == " ")
									codeText = codeText.substr(1);
								scan();
							} else
								break;
						}
						codeText += c;
						scan();
					}
					addBlock(options.icode(codeText));
					scan();
				}
			//
			//=============
			// [[url link
			} else if (eatChar("[")) {
				readBracketedLink() || addText("[");
			//
			//=============
			// normal char
			} else {
				addText(c);
				scan();
			}
		}
		flushText();
		closeAll(true);
		return output;
	} catch (e) {
		try {
			flushText();
			closeAll(true);
			addBlock(options.error());
			console.log(e);

			addText(code.substr(i));
			flushText();

			return output;
		} catch (e) {
			alert("Fatal parse error at: "+i);
		}
	}
	
	// ######################
	
	function eatChar(chr) {
		if (c == chr) {
			scan();
			return true;
		}
	}
	
	function readBracketedLink(embed) {
		if (c != "[") {
			return false;
		} else {
			scan();
			// read url:
			var start = i;
			var part2 = false;
			var url = readUrl(true);
			if (eatChar("]")) {
				if (eatChar("]"))
					;
				else if (eatChar("["))
					part2 = true;
			}
			startBlock(embed ? urlType(url) : 'link', {big: true}, url, preview);
			if (part2)
				stack.top().inBrackets = true;
			else {
				addText(url);
				endBlock();
			}
			return true;
		}
	}

	function addMulti(text, count) {
		while (count --> 0)
			addText(text);
	}

	// read a url
	// if `allow` is true, url is only ended by end of file or ]] or ][ (TODO)
	function readUrl(allow) {
		var start = i;
		if (allow)
			while (c && c!="]" && c!="[")
				scan();
		else
			while (isUrlChar(c))
				scan();
		return code.substring(start, i);
	}
	
	// ew regex
	function isUrlChar(c) {
		return c && (/[-\w\$\.+!*'(),;/\?:@=&#%]/).test(c);
	}
	
	// closeAll(true) - called at end of document
	// closeAll(false) - called at end of {} block
	function closeAll(force) {
		while(stack.length) {
			var top = stack.top();
			if (top.type == 'root') {
				break;
			}
			if (!force && top.type == null) {
				endBlock();
				break;
			}
			endBlock();
		}
	}
	
	function endLine() {
		while (1) {
			var top = stack.top();
			if (top.type == 'heading' || top.type == 'quote') {
				endBlock();
			} else if (top.type == 'item') {
				if (top.type == 'item')
					endBlock();
				var indent = 0;
				while (eatChar(" "))
					indent++;
				// OPTION 1:
				// no next item; end list
				if (c != "-") {
					while (top_is('list')) {//should ALWAYS happen at least once
						endBlock();
					}
					addMulti(" ", indent);
				} else {
					scan();
					while (eatChar(" "))
						;
					// OPTION 2:
					// next item has same indent level; add item to list
					if (indent == top.level) {
						startBlock('item', {level: indent});
						// OPTION 3:
						// next item has larger indent; start nested list	
					} else if (indent > top.level) {
						startBlock('list', {level: indent});
						startBlock('item', {level: indent}); // then made the first item of the new list
						// OPTION 4:
						// next item has less indent; try to exist 1 or more layers of nested lists
						// if this fails, fall back to just creating a new item in the current list
					} else {
						// TODO: currently this will just fail completely 
						while(1) {
							top = stack.top();
							if (top && top.type == 'list') {
								if (top.level <= indent) {
									break;
								} else {
									endBlock();
								}
							} else {
								// no suitable list was found :(
								// so just create a new one
								startBlock('list', {level: indent});
								break;
							}
						}
						startBlock('item', {level: indent});
					}
					break; //really?
				}
			} else {
				addLineBreak();
				break;
			}
		}
	}

	// audio, video, image, youtube (todo)
	function urlType(url) {
		if (/(\.mp3(?!\w)|\.ogg(?!\w)|\.wav(?!\w)|#audio$)/.test(url))
			return "audio";
		if (/(\.mp4(?!\w)|\.mkv(?!\w)|#video$)/.test(url))
			return "video";
		if (/(?:https?:\/\/)?(?:www\.)?youtu\.?be(?:\.com)?\/?.*(?:watch|embed)?(?:.*v=|v\/|\/)([\w\-_]+)\&?/.test(url))
			return "youtube";
		return "image";
	}
	
	// common code for all text styling tags (bold etc.)
	function doMarkup(type, create) {
		var symbol = c;
		scan();
		if (canStartMarkup(type)) {
			startBlock(type, {});
		} else if (canEndMarkup(type)) {
			endBlock();
		} else {
			addText(symbol);
		}
	}
	// todo: maybe have support for non-ASCII punctuation/whitespace?
	function canStartMarkup(type) {
		return (
			(!code[i-2] || char_in(code[i-2], " \t\n({'\"")) && //prev char is one of these (or start of text)
			!char_in(c, " \t\n,'\"") && //next char is not one of these
			!stackContains(type)
		);
	}
	function canEndMarkup(type) {
		return (
			top_is(type) && //there is an item to close
			!char_in(code[i-2], " \t\n,'\"") && //prev char is not one of these
			(!c || char_in(c, " \t\n-.,:!?')}\"")) //next char is one of these (or end of text)
		);
	}
	function char_in(chr, list) {
		return chr && list.indexOf(chr) != -1;
	}

	function lineStart() {
		startOfLine = true;
		leadingSpaces = 0;
	}
	
	function scan() {
		if (c == "\n" || !c)
			lineStart();
		else if (c != " ")
			startOfLine = false;
		else if (startOfLine)
			leadingSpaces++;
		i++;
		c = code.charAt(i);
	}

	// um like
	// don't use 'null' as a type name probably
	// In THis House
	// We use ==         ,
	function stackContains(type) {
		for (var i=0; i<stack.length; i++) {
			if (stack[i].type == type) {
				return true;
			}
		}
		return false;
	}
	function top_is(type) {
		var top = stack.top();
		return top && top.type == type;
	}

	function markCacheUnused() {
		for (type in cache)
			for (arg in cache[type])
				cache[type][arg].forEach(function(x){
					x.used = false;
				});
	}
	
	function findUnusedCached(type, arg) {
		var list = cache[type][arg]
		if (!list)
			return null;
		for (var i=0;i<list.length;i++) {
			if (!list[i].used)
				return list[i];
		}
		return null;
	}
	
	function startBlock(type, data, arg) {
		if (displayBlock[type]) {
			/*if (lastLineBreak) {
				options.remove(lastLineBreak);
			}*/
			skipNextLineBreak = true;
		}
		var node;
		if (cache && type && cache[type]) {
			var item = findUnusedCached(type, arg);
			if (item) {
				item.used = true;
				node = item.node;
			}
		}
		if (!node && type) {
			node = options[type](arg);
			
			if (cache && cache[type]) {
				if (!cache[type][arg])
					cache[type][arg] = [];
				cache[type][arg].push({node:node, used:true});
			}
		}
		
		data.type = type;
		if (type) {
			data.node = node;
			flushText();
			options.append(curr, data.node);
			curr = data.node;
		}
		stack.push(data);
		return data;
	}
	// add simple block with no children
	function addBlock(node) {
		flushText();
		options.append(curr, node);
	}
	function addText(text) {
		if (text) {
			textBuffer += text;
			lastLineBreak = null;
			if (skipNextLineBreak) {
				skipNextLineBreak = false;
			}
		}
	}
	function flushText() {
		if (textBuffer) {
			options.append(curr, options.text(textBuffer));
			textBuffer = ""
		}
	}
	function addLineBreak() {
		if (skipNextLineBreak) {
			skipNextLineBreak = false;
		} else {
			flushText();
			lastLineBreak = options.lineBreak();
			addBlock(lastLineBreak);
		}
	}
	function endBlock() {
		flushText();
		var node = stack.pop();
		if (displayBlock[node.type]) {
			skipNextLineBreak = true;
		}
		var i=stack.length-1;
		// this skips {} fake nodes
		// it will always find at least the root <div> element I hope
		while (!stack[i].node){
			i--;
		}
		curr = stack[i].node;
	}
}

Parse.lang.bbcode = function(code, preview) {
	var options = Parse.options;
	var output = options.root();
	var curr = output;
	var displayBlock = {
		h1:true,h2:true,h3:true,align:true,list:true,spoiler:true,youtube:true,quote:true,table:true,tr:true,img:true
	};
	var blocks = {
		b: options.bold,
		i: options.italic,
		u: options.underline,
		s: options.strikethrough,
		sup: options.superscript,
		sub: options.subscript,
		h1: function(){return options.heading(1)},
		h2: function(){return options.heading(2)},
		h3: function(){return options.heading(3)},
		table: options.table,
		tr: options.row,
		td: function(){return options.cell(false)},
		th: function(){return options.cell(true)},
		code: true, 
		align: options.align,
		url: options.link,//+<VERY special case> (only hardcode when no argument)
		youtube: true, //<special case>,
		img: true, //<special case>,
		list: options.list,
		spoiler: options.spoiler,
		quote: options.quote,
		anchor: function(arg){
			return options.anchor(arg);
		},
		item: options.item,
	};
	var specialBlock = {
		url: function(arg, args, contents){
			var node = options.link(contents);
			node.textContent = contents;
			return node;
		},
		code: function(arg, args, contents) {
			if (args)
				var lang = args.lang;
			if (arg == 'inline')
				return options.icode(contents, lang);
			return options.code(contents, lang);
		},
		youtube: function(arg, args, contents) {
			return options.youtube(contents, preview);
		},
		img: function(arg, args, contents) {
			return options.image(contents);
		}
	};
	
	var skipNextLineBreak;
	var lastLineBreak;
	
	var stack = [{node:curr, type:'root'}];
	stack.top = function() {
		return stack[stack.length-1];
	};
	var textBuffer = "";
	var point = 0;
	var i = -1;
	var c;
	scan();
	
	while (c) {
		//===========
		// [... tag?
		if (eatChar("[")) {
			point = i-1;
			if(eatChar("/")) {
				var name = readTagName();
				if (!eatChar("]") || !name) {
					cancel();
				} else {
					if (name == "list" && stack.top().type == "item") {
						endBlock(point);
					}
					if (name == stack.top().type) {
						endBlock(point);
					} else {
						cancel();
					}
				}
			} else {
				var name = readTagName();
				if (!name || !blocks[name]) {
					if (eatChar("*") && eatChar("]")) {
						if (stack.top().type == "item") {
							endBlock(point);
						}
						startBlock("item", undefined, undefined, i);
					} else {
						cancel();
					}
				} else {
					
					// [tag=...
					var arg = null, args = null;
					if (eatChar("=")) {
						var start=i;
						while (c && c!="]" && c!=" ")
							scan();
						if (c == "]" || c == " ")
							arg = code.substring(start, i);
					}
					if (eatChar(" ")) {
						args = readArgList();
					}
					if (eatChar("]")) {
						if (name == "youtube" || name == "img" || (name == "url" && !arg) || name == "code") {
							var endTag = "[/"+name+"]";
							var end = code.indexOf(endTag, i);
							if (end < 0)
								cancel();
							else {
								var contents = code.substring(i, end);
								i = end + endTag.length;
								i--;
								scan();
								addBlock(specialBlock[name](arg,args,contents));
								if (name == "youtube" || name=="img" || (name=="code" && arg != "inline"))
									skipNextLineBreak = true;
							}
						} else if (blocks[name]) {
							startBlock(name, arg, args, i);
						} else
							cancel();
					} else {
						cancel();
					}
				}
			}
		} else if (eatChar('\n')) {
			addLineBreak();
		} else {
			addText(c);
			scan();
		}
	}
	while (stack.length) {
		endBlock(i);
	}
	return output;
	
	function cancel() {
		addText(code.substring(point, i));
	}

	function readArgList() {
		var args = {};
		while (1) {
			// read key
			var start = i;
			while (isTagChar(c))
				scan();
			var key = code.substring(start, i);
			// key=...
			if (eatChar("=")) {
				// key="...
				if (eatChar('"')) {
					start = i;
					while (c && c!='"' && c!="\n")
						scan();
					if (eatChar('"'))
						args[key] = code.substring(start, i-2);
					else
						return null;
				// key=...
				} else {
					start = i;
					while (c && c!=" " && c!="]" && c!="\n")
						scan();
					if (c == "]") {
						args[key] = code.substring(start, i);
						return args;
					} else if (eatChar(" "))
						args[key] = code.substring(start, i-1);
					else
						return null;
				}
			// key ...
			} else if (eatChar(" ")) {
				args[key] = true;
			// key]...
			} else if (c == "]") {
				args[key] = true;
				return args;
			// key<other char> (error)
			} else
				return null;
		}
	}
	
	function readTagName() {
		var start = i;
		while (isTagChar(c))
			scan();
		return code.substring(start, i);
	}

	function isTagChar(c) {
		return c>="a" && c<="z" || c>="A"&&c<="Z" || c>="0"&&c<="9";
	}
		
	function eatChar(chr) {
		if (c == chr) {
			scan();
			return true;
		}
	}

	function scan() {
		i++;
		c = code.charAt(i);
	}

	// ###
	
	function addLineBreak() {
		if (skipNextLineBreak)
			skipNextLineBreak = false;
		else {
			flushText();
			lastLineBreak = options.lineBreak();
			addBlock(lastLineBreak);
		}
	}

	function addBlock(node) {
		flushText();
		options.append(curr, node);
	}
	
	function addText(text) {
		if (text) {
			textBuffer += text;
			skipNextLineBreak = false;
		}
	}

	function flushText() {
		if (textBuffer) {
			options.append(curr, options.text(textBuffer));
			textBuffer = "";
		}
	}

	function endBlock(index) {
		flushText();
		var item = stack.pop();
		if (displayBlock[item.type]) {
			skipNextLineBreak = true;
		}
		if (stack.length)
			curr = stack.top().node;
		else
			curr = null;
	}
	
	function startBlock(type, arg, args, index) {
		if (displayBlock[type]) {
			if (eatChar("\n")) //hack
				index++;
			else
				skipNextLineBreak = true;
		}
		var node = blocks[type](arg, args);
		stack.push({
			type: type,
			node: node,
			start: index,
			arg: arg
		});
		flushText();
		options.append(curr, node);
		curr = node;
	}
}

Parse.fallback = function(text) {
	var options = Parse.options;
	var root = options.root();
	var text = options.text(text);
	options.append(root, text);
	//todo: autolinker
	return root;
}
function renderPath(element, list) {
	element.innerHTML = "";
	if (!list)
		return;
	list.forEach(function(item, i, list) {
		if (item) {
			var link = document.createElement('a');
			link.href = item[0];
			link.textContent = item[1];
			link.className = "textItem pre";
			element.appendChild(link);
		}
		
		if (i < list.length-1) {
			var slash = document.createElement('span');
			slash.textContent = "/";
			slash.className = "pathSeparator textItem";
			element.appendChild(slash);
		}
	});
}

function userAvatar(user, cls, big) {
	if (cls.innerHTML != undefined)
		var img = cls
	else {
		img = document.createElement('img');
		img.className = cls+" avatar";
	}
	if (big)
		img.src = user.bigAvatarURL;
	else
		img.src = user.avatarURL;
	img.alt = user.username;
	return img;
}

function textItem(text) {
	var s = document.createElement('span');
	s.textContent = text;
	s.className = 'textItem';
	return s;
}

// todo: this should probably be like
// <a><figure><img><figcaption>
function renderUserLink(user, nameFirst) {
	var a = document.createElement('a');
	a.className = 'item userLink';
	if (user) {
		a.href = "#user/"+user.id;
		var name = textItem(user.username);
		name.className = "username textItem pre"
		var avatar = userAvatar(user, 'item');
		if (nameFirst)
			a.appendChild(name)
		a.appendChild(avatar)
		if (!nameFirst)
			a.appendChild(name)
	} else {
		a.textContent = "MISSINGNO. "
	}
	return a;
}

function renderTimeAgo(date) {
	var time = document.createElement('time');
	var d = parseDate(date)
	time.setAttribute('datetime',date);
	time.setAttribute('title',readableDate(d));
	time.textContent = timeAgo(d);
	time.className = "textItem time";
	return time;
}

function renderAuthorBox(page, users, element) {
	element.innerHTML = "";
	if (!page)
		return;
	/*element.appendChild(textItem("Author: "));*/
	element.appendChild(renderUserLink(users[page.createUserId], true));
	element.appendChild(renderTimeAgo(page.createDate));
	// page was edited by other user
	if (page.editUserId != page.createUserId) {
		element.appendChild(textItem(", edited by: "));
		var editedText = true;
		element.appendChild(renderUserLink(users[page.editUserId], true));
	}
	// page was edited
	if (page.createDate != page.editDate) {
		if (!editedText)
			element.appendChild(textItem(", edited "));
		element.appendChild(renderTimeAgo(page.editDate));
	}
}

function renderCategoryPage(page, users) {
	var user = users[page.createUserId];
	var div = document.createElement('a');
	div.href = "#pages/"+page.id;
	div.className = "pre categoryPage bar rem2-3";
	var title = document.createElement('span');
	title.className = "categoryPageTitle textItem";
	title.textContent = "\uD83D\uDCC4 " + page.name;
	div.appendChild(title);
	if (user) {
		var right = renderUserLink(user, true);
		right.className += ' rightAlign';
		div.appendChild(right);
	}
	return div;
}

function insertFirst(node, child) {
	if (node.firstChild)
		node.insertBefore(child, node.firstChild);
	else
		node.appendChild(child);
}

function renderUserPath(element, user) {
	element.innerHTML = "";
	var link = document.createElement('a');
	link.href = "#users"
	link.textContent = "Users";
	link.className = "textItem";
	element.appendChild(link);
	
	var slash = document.createElement('span');
	slash.textContent = "/";
	slash.className = "pathSeparator textItem";
	element.appendChild(slash);
	
	if (user) {
		link = document.createElement('a');
		link.href = "#user/"+user.id
		link.textContent = user.username;
		link.className = "textItem";
		element.appendChild(link);	
	}
}

function renderActivityPath(element) {
	element.innerHTML = "";
	var link = document.createElement('a');
	link.href = "#activity"
	link.textContent = "Activity";
	link.className = "textItem";
	element.appendChild(link);
	
	var slash = document.createElement('span');
	slash.textContent = "/";
	slash.className = "pathSeparator textItem";
	element.appendChild(slash);
}

function timeString(date) {
	var hours = date.getHours();
	var minutes = date.getMinutes();
	var twelve = hours % 12 || 12;
	return twelve+":"+("00"+minutes).substr(-2)+" "+["AM","PM"][hours >= 12 |0];
}

function renderSystemMessage(text) {
	var node = document.createElement('div');
	node.className = 'message systemMessage';
	node.textContent = text;
	return node;
}

function renderUserListAvatar(user) {
	var a = userAvatar(user, "userListAvatar");
	a.title = user.username;
	return a;
}

function renderUserBlock(user, date) {
	var div = document.createElement('div');
	div.className = 'message';

	div.appendChild(userAvatar(user, 'avatar'));
	
	var name = document.createElement('span');
	name.className = 'username';
	name.textContent = user.username+":";
	div.appendChild(name);
	
	var time = document.createElement('span');
	time.textContent = timeString(date);
	time.className = 'messageTime'
	div.appendChild(time);
	
	var contentBox = document.createElement('div');
	contentBox.className = 'messageContents';
	div.appendChild(contentBox);
	return [div, contentBox];
}

function renderCategory(cat, users) {
	var div = document.createElement('a');
	div.href = "#categories/"+cat.id;
	div.className = "pre categoryPage rem2-3 bar";
	var title = document.createElement('span');
	title.className = "categoryPageTitle item";
	title.textContent = "\uD83D\uDCC1 "+cat.name;
	div.appendChild(title);
	return div;
}

function readableDate(date) {
	return date.toLocaleString();
}

function timeAgo(date) {
	var seconds = Math.floor((new Date() - date) / 1000);
	var interval = Math.floor(seconds / 31536000);
	if (interval >= 1) return interval + " years ago";
	interval = Math.round(seconds / 2592000);
	if (interval >= 1) return interval + " months ago";
	interval = Math.round(seconds / 86400);
	if (interval >= 1) return interval + " days ago";
	interval = Math.round(seconds / 3600);
	if (interval >= 1) return interval + " hours ago";
	interval = Math.round(seconds / 60);
	if (interval >= 1) return interval + " minutes ago";
	if (seconds < 0)
		return " IN THE FUTURE?";
	return Math.round(seconds) + " seconds ago";
	//return date.getFullYear()+"/"+(date.getMonth()+1)+"/"+date.getDate()+" "+date.getHours()+":"+date.getMinutes();
}

function renderPageContents(page, element, cache) {
	if (page.values) {
		var parser = Parse.lang[page.values.markupLang];
	}
	parser = parser || Parse.fallback;
	if (element) {
		setChild(element, parser(page.content, false, cache));
	} else {
		return parser(page.content, false, cache);
	}
}

function setChild(element, child) {
	element.innerHTML = "";
	element.appendChild(child);
}

// as far as I know, the o3DS doesn't support parsing ISO 8601 timestamps
function parseDate(str) {
	var data = str.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:.\d+)?)/);
	if (data) {
		var sec = Math.floor(+data[6]);
		var ms = +data[6] - sec;
		return new Date(Date.UTC(+data[1], +data[2]-1, +data[3], +data[4], +data[5], sec, ms));
	}
	return new Date(0);
}

function renderActivityItem(activity, page, user) {
	if (!user)
		user = [];
	else if (!(user instanceof Array))
		user = [user];

	switch(activity.action) {
	case "c":
		var text = "Created";
		break;case "u":
		text = "Edited";
		break;case "d":
		text = "Deleted";
		break;case "p":
		text = "Posted on";
		break;default:
		text = "Unknown action";
	}
	var div = document.createElement('a');
	div.className = "listItem bar rem1-5";
	var action = document.createElement('span');
	action.className = "textItem";
	action.textContent = text;
	var link = document.createElement('b');
	link.className = "textItem pre";
	if (activity.action =="p")
		div.href = "#discussions/"+activity.contentId;
	else
		div.href = "#pages/"+activity.contentId;
	link.textContent = " "+page.name+" ";
	
	user.forEach(function(user){
		var usr = document.createElement('a');
		usr.className = 'item';
		usr.href = "#user/"+user.id;
		
		var name = document.createElement('span');
		name.textContent = user.username;
		name.className = "textItem";
		usr.appendChild(userAvatar(user, 'item'));
		usr.appendChild(name);
		div.appendChild(usr);
		div.appendChild(document.createTextNode(" "));
	});
	div.appendChild(action);
	div.appendChild(link);
	var time = renderTimeAgo(activity.date);
	time.className += " rightAlign";
	div.appendChild(time);
	return div;
}

function renderMemberListUser(user) {
	var div = renderUserLink(user)
	div.className = "member userLink rem2-3";
	return div;
}

function renderMessagePart(comment, sizedOnload){
	var c = comment.content;
	var t, m;
	try {
		c = JSON.parse(c);
		if (c.t)
			t = c.t;
		else
			t = c;
		m = c.m;
	} catch (e) {
		t = c;
	}
	/*if (m == '12y') {
		//todo: update for parser aaaa
		element = parse(t);
		var x = element.getElementsByTagName('img');
		for (var i=0;i<x.length;i++) {
			x[i].onload = sizedOnload;
		}
	} else {*/
		element = document.createElement('div');
		element.appendChild(document.createTextNode(t));
	//}
	element.className += ' messagePart';
	//document.title=comment.username+":"+t;
	return element;
}

function hide(element) {
	element.style.display = 'none';
}

function show(element) {
	element.style.display = '';
}

function visible(element, state) {
	element.style.display = state ? '' : 'none';
}

// Based on sbs chat autoscroller
function AutoScroller(element) {
	this.element = element;
	this.smoothScroll = true;
	this.nodes = {};
	this.blocks = {};
	var $=this;
	function onresize() {
		//todo: make this only happen when the element was previously scrolled to bottom
		// may need to detect onscroll to keep track
		// I'd like to avoid onscroll for o3ds though (especially since window can't even be resized so it doesn't matter) (also does o3DS EVEN HAVE onscroll lol)
		$.autoScroll(true);
	};
	//window.addEventListener('resize', onresize); //todo: only do this whe nin chat mode!!
}
// do autoscroll
AutoScroller.prototype.autoScroll = function(instant) {
	var parent = this.element.parentNode;
	if (!window.requestAnimationFrame || !this.smoothScroll || instant) {
		parent.scrollTop = parent.scrollHeight - parent.clientHeight;
	} else {
		// only start a new animation if previous isn't already running
		if (!this.animationId) {
			this.autoScrollAnimation();
		}
	}
}
// check if element is scrolled to near the bottom (within 0.25*height)
// this threshold can probably be decreased...
AutoScroller.prototype.shouldScroll = function() {
	return this.scrollDistance() < this.element.parentNode.clientHeight*0.25;
}
// check distance to bottom
AutoScroller.prototype.scrollDistance = function() {
	var parent = this.element.parentNode;
	return parent.scrollHeight-parent.clientHeight-parent.scrollTop;
}

// scrolls down until reaching bottom
// stops if interrupted by user scrolling
AutoScroller.prototype.autoScrollAnimation = function() {
	var $=this;
	var parent = this.element.parentNode;

	parent.scrollTop += Math.max(Math.ceil(this.scrollDistance()/4), 1);
	
	if (this.scrollDistance() > 0) {
		// save scroll position
		this.expectedTop = parent.scrollTop;
		this.animationId = window.requestAnimationFrame(function(time) {
			// only call again if scroll pos has not changed
			// (if it has, that means the user probably scrolled manually)
			if ($.expectedTop == $.element.parentNode.scrollTop) {
				$.autoScrollAnimation();
			} else {
				$.animationId = null;
			}
		});
	} else {
		this.animationId = null;
	}
}
AutoScroller.prototype.insert = function(id, node, uid, makeBlock) {
	var s = this.shouldScroll();
	// replace an existing message (we assume uid doesn't change)
	if (this.nodes[id]) {
		this.nodes[id].parentNode.replaceChild(node, this.nodes[id]);
	// insert a new line to the last block
	} else if (uid && this.lastUid == uid) {
		this.lastUidBlock.appendChild(node);
	// create a new block
	} else {
		var b = makeBlock();
		b[1].appendChild(node);
		this.element.appendChild(b[0]);
		
		this.lastUidBlock = b[1];
		this.lastUid = uid;
	}
	this.nodes[id] = node;
	if (s)
		this.autoScroll();
}
AutoScroller.prototype.remove = function(id) {
	var node = this.nodes[id]
	// todo: remove block when all messages are gone from it
	// don't forget to update lastUidBlock etc. too
	if (node) {
		node.parentNode.removeChild(node);
	}
	this.nodes[id] = undefined;
}
// currently just clears no matter what
// in the future you might, if this is properly connected to a LongPoller,
// cache messages when switching rooms, or something
AutoScroller.prototype.switchRoom = function(id) {
	this.element.innerHTML = "";
	this.lastUid = undefined;
	this.lastUidBlock = undefined;
	this.nodes = {};
	// probably needs more cleanup
}

AutoScroller.prototype.embed = function(node) {
	var s = this.shouldScroll();
	this.element.appendChild(node);
	this.lastUid = null;
	this.lastUidBlock = null;
	if (s)
		this.autoScroll();
}
var flags = {};
function flag(flag, state) {
	if (!flags[flag] != !state) {
		if (state)
			flags[flag] = true;
		else
			delete flags[flag];
		var cls = "";
		for (flag in flags) {
			cls += " f-"+flag;
		}
		document.documentElement.className = cls;
	}
}

var uploadedAvatar;

// clean up stuff whenever switching pages
function cleanUp() {
	flag('myUserPage');
	$messageList.innerHTML = "";
	$authorBox.innerHTML = "";
	var nodes = document.querySelectorAll(".markup-root");
	for (var i=0;i<nodes.length;i++) {
		nodes[i].innerHTML = "";
	}
}

function setTitle(text) {
	$pageTitle.textContent = text;
}

function generateSettingsView(n, callback) {
	// maybe merge this with the register page somehow?
	// only one of them really works at a time anyway
	if (me.auth) {
		me.getSettings(function(user, page) {
			cleanUp();
			$main.className = "settingsMode";
			generateAuthorBox();
			generatePath([["#usersettings","Settings"]]);
			if (user) {
				setTitle("User Settings: " + user.username);
				userAvatar(user, $settingsAvatar);
				if (page) {
					$userPageLink.href = "#pages/edit/"+page.id;
				} else {
					$userPageLink.href = "#pages/edit?type=@user.page&name=User Page";
				}
			}
			callback();
		});
	} else {
		cleanUp();
		$main.className = "errorMode";
		setTitle("WHAT IS YOUR NAME?");
	}
}

var editingPage;
var editorCache = {};

function newPage(query) {
	return {
		parentId: +query.cid || 0,
		type: query.type || "@page.resource",
		name: query.name || "",
		values: {
			markupLang: "12y"
		},
		permissions: {
			0: "cr"
		},
		keywords: []
	};
}

function fillEditorFields(page) {
	$titleInput.value = page.name || "";
	if (page.values)
		var markup = page.values.markupLang;
	if (!markup)
		markup = "12y";
	$markupSelect.value = markup;
	if (page.content)
		$editorTextarea.value = page.content;
	updateEditorPreview();
	$keywords.value = page.keywords.join(" ");
	$permissions.value = JSON.stringify(page.permissions);
	$editPageType.value = page.type;
	generatePath(makeCategoryPath(me.categoryTree, page.parentId, page.name ? page : undefined));
}

function readEditorFields(page) {
	page.name = $titleInput.value;
	page.values.markupLang = $markupSelect.value;
	page.keywords = $keywords.value.split(" ");
	page.permissions = JSON.parse($permissions.value);
	page.type = $editPageType.value;
	page.content = $editorTextarea.value;
}

// call this function with no `id` to create a new page
// remember to set .cid in `query` so it knows what parentId to use

// idea: when editing, store the parent category/whatever somewhere, to tell where to go back to when deleting/ and also a way to send you to your user page when editing that I guess.
function generateEditorView(id, query, callback) {
	me.getPageForEditing(id, go);
	// if there's no ID, getPageForEditing will just
	// get the category tree if it's needed
	
	function go(page, users) {
		cleanUp();
		$main.className = "editorMode";
		generateAuthorBox(page, users);
		visible($deletePage, page && /d/.test(page.myPerms));
		visible($submitEdit, !page || /u/.test(page.myPerms));
		//todo: set buttons to "disabled" instead maybe
		// and add explanation of permissions?
		//make it more clear when you can't modify page, especially
		
		if (page) {
			setTitle("Editing:");
			editingPage = page;
		} else {
			setTitle("Creating:");
			editingPage = newPage(query);
			$titleInput.focus();
		}
		fillEditorFields(editingPage);
		callback();
	}
}

function generateHomeView(idk, callback) {
	cleanUp();
	$main.className = "homeMode";
	generateAuthorBox();
	generatePath();
	setTitle("Welcome to smilebnasic soruce! 2");
	callback();
}

function attr(element, attr, value) {
	if (value == undefined)
		element.removeAttribute(attr)
	else
		element.setAttribute(attr, value);
}

function generatePageView(id, callback) {
	loadStart();
	me.getPage(id, function(page, users, comments){
		cleanUp();
		$main.className = "pageMode";
		generateAuthorBox(page, users);
		visible($pageEditButton, page);
		if (page) {
			currentPage = page.id;
			generatePath(makeCategoryPath(me.categoryTree, page.parentId, page));
			setTitle("\uD83D\uDCC4 " + page.name);
			$watchCheck.checked = page.about.watching;
			// todo: handle showing/hiding the vote box when logged in/out
			renderPageContents(page, $pageContents)
			$pageEditButton.href = "#pages/edit/"+page.id;
			$voteCount_b.textContent = page.about.votes.b.count;
			$voteCount_o.textContent = page.about.votes.o.count;
			$voteCount_g.textContent = page.about.votes.g.count;
			["b","o","g"].forEach(function(vote) {
				window['$voteCount_'+vote].textContent = page.about.votes[vote].count;
				attr(window['$voteButton_'+vote], 'data-selected', page.about.myVote == vote ? "" : undefined);
			});
		} else {
			currentPage = null;
			setTitle("Page not found");
			generatePath();
			$main.className = "errorMode";
		}
		callback();
	});
}

function megaAggregate(activity, ca, contents) {
	var contentMap = {};
	contents.forEach(function(x){
		contentMap[x.id] = x;
	})
	var allAct = activity.concat(ca.map(function(x){
		return {
			action: "p",
			contentId: x.id,
			date: x.lastDate,
			firstDate: x.firstDate,
			id: x.lastId,
			userId: x.userIds,
			type: 'content',
		}
	}));
	allAct.forEach(function(x) {
		if (x.action == 'd')
			x.content = {name: x.extra, id: x.contentId, deleted: true};
		else
			x.content = contentMap[x.contentId];
	});
	allAct.sort(function(a, b) {
		return a.date < b.date;
	});
	//todo: trim all trailing of same type because that's when the other runs out
	// also we can optimize merging of 2 sorted arrays here!
	return allAct;
}

function generatePath(path) {
	renderPath($navPane, path);
}
// function generatePagePath - category tree paths

function generateUserView(id, callback) {
	me.getUserPage(id, function(user, page, activity, ca, pages, userMap) {
		cleanUp();
		$main.className = 'userMode';
		// todo: change edit box to "Joined: <date>" and "page edited: <date>"
		generateAuthorBox(user && page, userMap);
		generatePath([["#users","Users"], ["#user/"+id, user.username]]);
		$userPageAvatar.src = "";
		$userActivity.innerHTML = "";
		if (page) {
			$pageEditButton.href = "#pages/edit/"+page.id;
		} else if (id == me.uid) {
			$pageEditButton.href = "#pages/edit?type=@user.page&name=User Page";
		} else {
			//todo: hide
			$pageEditButton.removeAttribute('href');
		}
		if (user) {
			if (user.id == me.uid)
				flag('myUserPage', true);
			setTitle(user.username);
			if (page) {
				renderPageContents(page, $userPageContents)
			} else {
				$userPageContents.innerHTML = "";
			}
			userAvatar(user, $userPageAvatar, true);
			$userPageAvatarLink.href = user.rawAvatarURL;
			var lastId, lastAction;
			megaAggregate(activity, ca, pages).forEach(function(activity){
				if (activity.type != "content") //idk, category?
					return;
				if (activity.contentId != lastId || activity.action != lastAction) {
					if (activity.content) {
						$userActivity.appendChild(renderActivityItem(activity, activity.content));
						lastId = activity.contentId;
						lastAction = activity.action;
					}
				}
			});
		} else {
			$main.className += " errorMode";
			setTitle("User Not Found");
		}
		callback();
	});
}

function generateChatView(id, callback) {
	// todo: make this work when logged out
	// use a normal request at first and then switch on the long poller IF logged in
	lp.callback = function(comments, listeners, userMap, page) {
		if (page && page.id == id) {
			generatePath(makeCategoryPath(me.categoryTree, page.parentId, page));
			generateAuthorBox(page, userMap);
			$messageList.innerHTML = ""
			$main.className = "chatMode";
			scroller.switchRoom(id);
			setTitle(page.name);
			renderPageContents(page, $pageContents);
			callback();
		} else if (page == false) { //1st request, page doesn't exist
			generatePath();
			generateAuthorBox(page, userMap);
			$messageList.innerHTML = ""
			setTitle("Page not found");
			$pageContents.innerHTML = "";
			callback();
			// TODO: page list passed to callback needs to be PER-ID!!
		}
		if (comments) {
			comments.forEach(function(comment) {
				if (comment.parentId == id)
					displayMessage(comment, userMap[comment.createUserId]);
			});
		}
		if (listeners)
			updateUserlist(listeners[id], userMap);
		if (page) {
			scroller.autoScroll(true);
		}
	}
	lp.addRoom(id);
}

function displayMessage(c, user) {
	if (c.deleted) {
		scroller.remove(c.id);
	} else {
		var node = renderMessagePart(c, function(){
			scroller.autoScroll();
		});
		scroller.insert(c.id, node, c.createUserId, function() {
			var b = renderUserBlock(user, parseDate(c.createDate));
			if (c.createUserId == me.uid)
				b[0].className += " ownMessage";
			return b;
		});
	}
}

function generateCategoryView(id, callback) {
	me.getCategory(id, 50, 0, 'editDate', false, function(category, childs, contentz, users) {
		cleanUp();
		$main.className = 'categoryMode';
		
		$categoryPages.innerHTML = "";
		$categoryCategories.innerHTML = "";
		$categoryDescription.textContent = "";
		if (category) {
			contentz.reverse();
			generatePath(makeCategoryPath(me.categoryTree, category.id));
			setTitle("\uD83D\uDCC1 "+category.name);
			$categoryDescription.textContent = category.description;
			childs.forEach(function(cat) {
				$categoryCategories.appendChild(renderCategory(cat, users));
			});
			$categoryPages.style.display="none";
			contentz.forEach(function(content) {
				$categoryPages.appendChild(renderCategoryPage(content, users));
			});
			$categoryPages.style.display="";
			$categoryCreatePage.href = "#pages/edit?cid="+category.id;
		} else {
			generatePath();
			$categoryCreatePage.href = ""
			$main.className += "errorMode";
			setTitle("Category not found");
		}
		callback();
	});
}

function generateMembersView(idk, callback) {
	me.getUsers({}, function(users) {
		cleanUp();
		$main.className = 'membersMode';
		$memberList.innerHTML = "";
		renderUserPath($navPane);
		setTitle("Users");
		users.forEach(function(user) {
			$memberList.appendChild(renderMemberListUser(user));
		});
		callback();
	});
}

function generateActivityView(idk, callback) {
	me.getActivity(function(activity, ca, pages, users) {
		cleanUp();
		$main.className = 'activityMode';
		renderActivityPath($navPane);
		if (activity) {
			setTitle("Activity");
			var last = {};
			$activity.innerHTML = "";
			megaAggregate(activity, ca, pages).forEach(function(activity){
				if (activity.type != "content") //idk, category?
					return;
				if (activity.contentId != last.contentId || activity.action != last.action || activity.userId != last.userId) {
					if (activity.content) {
						if (activity.userId instanceof Array)
							var user = activity.userId.map(function(x){
								return users[x];
							})
						else
							user = users[activity.userId]
						$activity.appendChild(renderActivityItem(activity, activity.content, user));
						last = activity;
					}
				}
			});
		}
	});
}

function generateRegisterView(idk, callback) {
	cleanUp();
	$main.className = "registerMode";
	generateAuthorBox();
	generatePath();
	$pageTitle.textContent = "Create an account";
	callback();
}
//bug: when going back from another site, page is loaded from cache, and
// certain things are not reloaded

// idea: 'protected' mode, during page editing
// gives warning before navigation
// or: just save editing page contents lol

var me = new Myself(true);
me.loadCachedAuth(function(){});
var scroller;
var lp = new DiscussionLongPoller(me, null);
var currentPage;
flag('sidebar', localStorage.getItem('sbs-sidebar') == 'true');

debugMessage = function(text) {
	scroller.embed(renderSystemMessage(String(text)));
}

if (document.readyState == 'loading')
	document.addEventListener('DOMContentLoaded', ready);
else {
	ready();
}

function ready() {
	if (me.openRequests) {
		loadStart();
	}
	me.onLoadStart = loadStart;
	me.onLoadEnd = loadEnd;
	console.info("ready");
	if (me.auth)
		onLogin(me);
	else
		onLogout();
	
	me.on('login', function(gotUser) {
		onLogin(me);
	});
	me.on('logout', function() {
		onLogout(me);
	});
	
	$loggedOut.$login.onclick = function() {
		event.preventDefault();
		me.logOut();
		me.logIn($loggedOut.$username.value, $loggedOut.$password.value, function(){});
	}
	$logout.onclick = function() {
		event.preventDefault();
		me.logOut();
	}

	$editorTextarea.oninput = function() {
		updateEditorPreview(true);
	}
	$markupSelect.onchange = function() {
		updateEditorPreview(true);
	}
	$markupUpdate.onclick = function() {
		updateEditorPreview(false);
	}

	$submitEdit.onclick = submitEdit;
	$deletePage.onclick = deletePage;
	
	$chatSend.onclick = function() {
		if ($chatTextarea.value) {
			me.postComment(lp.idList[0], $chatTextarea.value, "plaintext", function(){});
			$chatTextarea.value = "";
		}
	}

	$chatTextarea.onkeypress = function(e) {
		if (!e.shiftKey && e.keyCode == 13) {
			e.preventDefault();
			$chatSend.onclick();
		}
	};

	var voteBtns = [$voteButton_b, $voteButton_o, $voteButton_g];
	// todo: this breaks when clicking things INSIDE the button
	//wtf
	// todo: update counts when changing
	$voteBox.addEventListener('click', function(e){
		var btn = e.target;
		if (voteBtns.indexOf(btn) == -1)
			return;
		var selected = e.target.getAttribute('data-selected');
		voteBtns.forEach(function(btn) {
			btn.removeAttribute('data-selected');
		});
		if (selected)
			e.target.removeAttribute('data-selected');
		else
			e.target.setAttribute('data-selected', "true");
		var vote = !selected ? e.target.getAttribute('data-vote') : null;
		me.setVote(currentPage, vote, function(e){
		});
	},true);
	
	$watchCheck.onchange = function() {
		me.setWatch(currentPage, $watchCheck.checked, function(){});
	}
	
	$registerForm.$register.onclick = function(e) {
		e.preventDefault();
		$registerError.textContent = "";
		var email = $registerForm.email.value;
		me.register($registerForm.username.value, $registerForm.password.value, email, function(e, resp) {
			console.log(e, resp, resp.errors);
			if (e == 'error' && resp) {
				var errors = ["Registration failed:"];
				if (resp.errors) {
					for (var key in resp.errors) {
						errors.push(resp.errors[key].join(" "));
					}
				} else
					errors.push(resp);
				$registerError.textContent = errors.join("\n");
			} else if (!e) {
				$registerError.textContent = "Sending email...";
				me.sendEmail(email, function(e, resp){
					if (!e) {
						$registerError.textContent = "Confirmation email sent";
					} else {
						$registerError.textContent = "Error sending confirmation email";
					}
				});
			}
		});
	}
	$resendEmail.onclick = function(e) {
		me.sendEmail($registerForm.email.value, function(e, resp){
			if (!e) {
				$registerError.textContent = "Confirmation email sent";
			} else {
				$registerError.textContent = "Error sending confirmation email";
			}
		});
	}
	$registerConfirm.onclick = function() {
		// todo: validate the key client-side maybe
		me.confirmRegister($emailCode.value, function(e, resp) {
			if (!e) {
				$registerError.textContent = "Registration Complete";
				window.location.hash = "#user/"+me.uid;
			} else {
				$registerError.textContent = "Failed to confirm registration";
			}
		});
	}

	$settingsAvatarUpload.onchange = function() {
		var reader = new FileReader();
		uploadedAvatar = new FormData();
		uploadedAvatar.append('file', this.files[0]);
	};

	//todo: when avatar changes, update internal cache and whatever
	// need to especially change the avatar in the corner of the screen
	// aaaaaaa eventssss
	$settingsAvatarSubmit.onclick = function() {
		if (uploadedAvatar) {
			me.uploadFile(uploadedAvatar, function(e, resp) {
				if (!e) {
					me.setBasic({avatar:resp.id},console.log);
				}
			});
			uploadedAvatar = null;
		}
	}
	
	scroller = new AutoScroller($messageList);

	hashChange(true);
	//console.log = debugMessage;
	/*$reload.onclick = function(){
		hashChange();
	}*/

	$openSidebar.onclick = $closeSidebar.onclick = toggleSidebar;
}

function toggleSidebar() {
	flag('sidebar', !flags.sidebar);
	localStorage.setItem('sbs-sidebar', flags.sidebar);
}

var currentPath = null;

// todo: add a "force" flag
function hashChange(first) {
	var fragment = getPath();
	if (currentPath == fragment[0]) {
		scrollTo(fragment[1])
	} else {
		currentPath = fragment[0];
		navigateTo(fragment[0], first, function() {
			scrollTo(fragment[1])
		});
	}
	
}

function scrollTo(name) {
	if (name) {
		var n = document.getElementsByName("_anchor_"+name);
		if (n[0])
			n[0].scrollIntoView();
	}
}

window.onhashchange = function() {
	// todo: when a link which has the same path but a different fragment is clicked,
	// page should not reload, instead just scroll to fragment
	hashChange(false);
}

function getPath() {
	var hash = decodeURIComponent(location.hash.substr(1));
	return hash.split("#");
}

function split1(string, sep) {
	var n = string.indexOf(sep);
	if (n == -1)
		return [string, null];
	else
		return [string.substr(0,n), string.substr(n+sep.length)];
}

function navigateTo(path, first, callback) {
	lp.reset();
	path = split1(path, "?");
	var query = path[1];
	var queryVars = {};
	if (query) {
		query.split("&").forEach(function(item) {
			item = split1(item, "=");
			if (item[1] == null) {
				queryVars[item[0]] = true;
			} else {
				queryVars[item[0]] = item[1];
			}
		});
	}
	path = path[0].split("/").filter(function(x){return x;});
	
	var type = path[0];
	var id = +(path[1]);
	if (type == "pages") {
		if (path[1] == "edit") {
			first && ($main.className = 'editMode');
			if (path[2]) {
				path[2] = path[2].split(/[&?]/g);
				id = +(path[2][0]);
			} else {
				id = undefined;
			}
			generateEditorView(id, queryVars, callback);
		} else {
			first && ($main.className = 'pageMode');
			generatePageView(id, callback);
		}
	} else if (type == "categories") {
		first && ($main.className = 'categoryMode');
		generateCategoryView(id, callback);
	} else if (type == "user") {
		first && ($main.className = 'userMode');
		generateUserView(id, callback);
	} else if (type == "users") {
		first && ($main.className = 'membersMode');
		generateMembersView(null, callback);
	} else if (type == "discussions") {
		first && ($main.className = 'chatMode');
		generateChatView(id, callback);
	} else if (typeof type == 'undefined') { //home
		first && ($main.className = 'homeMode');
		generateHomeView(null, callback);
	} else if (type == 'register') {
		first && ($main.className = 'registerMode');
		generateRegisterView(null, callback);
	} else if (type == 'usersettings') {
		first && ($main.className = 'settingsMode');
		generateSettingsView(null, callback);
	} else if (type == 'activity') {
		first && ($main.className = 'activityMode');
		generateActivityView(null, callback);
	} else {
		$main.className = "errorMode";
		generateAuthorBox();
		$pageTitle.textContent = "[404] I DON'T KNOW WHAT A \""+type+"\" IS";
		renderPath($navPane);
		$pageContents.textContent = "";
		callback();
	}
}

function makeCategoryPath(tree, id, leaf) {
	var node = tree.map[id];
	var path = [];
	while (node) {
		path.unshift(["#categories/"+node.id, node.name])
		node = node.parent;
	}
	if (leaf) {
		path.push(["#pages/"+leaf.id, leaf.name]);
	} else {
		path.push(null);
	}
	return path;
}

// These are used to signal to the user when content is loading
function loadStart(lp) {
	if (!lp)
		flag('loading', true);
	/*if (window.$titlePane)
		window.$titlePane.style.backgroundColor = "#48F";*/
}
function loadEnd(lp, e) {
	if (!lp) {
		flag('loading');
	}
	/*$titlePane.style.backgroundColor = "";*/
}

//maybe turn the title <h1> into an input box
//so you can just edit the page title there
function submitEdit() {
	readEditorFields(editingPage);
	me.postPage(editingPage, function(e, resp) {
		if (e) {
			alert("ERROR");
		} else {
			window.location.hash = "#pages/"+resp.id;
		}
	});
}

function deletePage() {
	if (editingPage && editingPage.id) {
		var result = confirm("Are you sure you want to delete this page?");
		if (result) {
			// once the page is deleted, it should take you to the category (I guess)
			me.deletePage(editingPage.id, function(e, resp) {
				if (e) {
					alert("ERROR");
				} else {
					window.location.hash = "#categories/"+editingPage.parentId;
				}
			});
		}
	}
}

var editorCache = {video:{},audio:{},youtube:{}};
function updateEditorPreview(preview) {
	renderPageContents({
		values: {
			markupLang: $markupSelect.value
		},
		content: $editorTextarea.value
	}, $editorPreview, editorCache);
}

// "generate" functions operate implicitly on specific html elements, and should be in view.js
// "render" functions often are similar but more general, and are in render.js
// I feel like the names are backwards, sorry...
function generateAuthorBox(page, users) {
	renderAuthorBox(page, users, $authorBox);
}

function updateUserlist(listeners, userMap) {
	$chatUserlist.innerHTML = "";
	listeners && listeners.forEach(function(l) {
		$chatUserlist.appendChild(renderUserListAvatar(userMap[l]));
	})
}

function onLogin(me) {
	me.whenUser(me.uid, function(user) {
		userAvatar(user, $myAvatar);
		$myName.textContent = user.username;
		$myUserLink.href = "#user/"+user.id;
	});
	flag("loggedIn",true);
}

function onLogout() {
	$myAvatar.src = "";
	$myName.textContent = "";
	flag("loggedIn");
}
</script>
<title>DAVE'S SHIT HOLE</title>

<body class="pageMode" id="$main">
	<!--
		 
	  -->
	<nav class="headerPane bar">
		<a href="#" class="textItem"><img class="item" src="fav-big.png?b" alt="SBS"></a>
		<span id="$navPane" class="path textItem"></span>

		<span class="rightAlign textItem">
			<button id="$openSidebar" class="item">|||</button><!--<button id="$reload" class="item">Reload</button>--><!--<input id="$search" placeholder="Search" class="item">--><div class="loggedIn textItem" id="$loggedIn"><a class="textItem userLink" id="$myUserLink"><span class="myName username textItem" id="$myName" class="item"></span><img class="myAvatar item avatar" id="$myAvatar"></a></div>
		</span>
	</nav>

	<header class="titlePane bar rem2-3" id="$titlePane">
		<h1 class="pageTitle textItem pre" id="$pageTitle"></h1>
		<a class="textItem userMode loggedIn myUserPage" href="#usersettings">Settings</a><button id="$logout" class="textItem loggedIn myUserPage">Log Out</button>
		<input class="item editorMode" id="$titleInput" placeholder="Page Title" required>
		<span class="editorMode textItem">
			<button id="$submitEdit" class="item">Submit</button><div class="textItem"></div>
		</span>
		<span class="textItem pageMode" id="$voteBox"><button id="$voteButton_b" class="item voteButton" data-vote="b">Bad<br><span id="$voteCount_b">x</span></button><button id="$voteButton_o" class="item voteButton" data-vote="o">Ok<br><span id="$voteCount_o">x</span></button><button id="$voteButton_g" class="item voteButton" data-vote="g">Great<br><span id="$voteCount_g">x</span></button></span>
		<label for="$watchCheck" class="textItem pageMode">Watching:</label>
		<input type="checkbox" id="$watchCheck" class="item pageMode">

		<div class="pageCreate textItem rightAlign">
			<button id="$deletePage" class="item editorMode">DELETE</button>
			<a class="textItem pageUserMode" id="$pageEditButton"><button class="item" tabindex="-1">Edit</button></a>
			<span class="textItem" id="$authorBox"></span>
		</div>
	</header>

	<div class="sideBarContainer">
		<div class="m">
			<div class="userlistPane userlist rem2-3 chatMode bar" id="$chatUserlist"></div>
			
			<div class="infoPane editorMode">
				<label for="$keywords">Keywords:</label><input placeholder="(space separated, optional)" id="$keywords"><br>
				<label for="$editPageType">Type:</label><input placeholder="@" id="$editPageType"><br>
				<label for="$permissions">Permissions:</label><input id="$permissions"><br>
				<label for="$markupSelect">Markup language:</label>
				<select id="$markupSelect">
					<option value="plaintext">plain text</option>
					<option value="12y">12-y documentation markup format</option>
					<option value="bbcode">bbcode</option>
				</select><button id="$markupUpdate">Update</button>
			</div>

			<div class="activityMode categoryNav">
				<span class="textItem"><button id="$categoryPagesPrev" class="item">&lt;</button><button id="$categoryPagesNext" class="item">&gt;</button></span>
			</div>
			
			<div class="membersMode">
				<span class="textItem"><button id="$membersPrev" class="item">&lt;</button><button id="membersNext" class="item">&gt;</button></span>
			</div>

			<div class="userPageBox userMode">
				<a id="$userPageAvatarLink"><img id="$userPageAvatar" class="userPageAvatar avatar"></a>
				<div class="pageContents pre userPageContents" id="$userPageContents"></div>
			</div>
			
			<!--
				 These panes have the main content
				 one of them will be visible at a time, depending on the view mode
			  -->
			
			<main class="paneGrow scroller">
				<div id="$categoryDescription" class="categoryDescription pre pageContents categoryMode"></div>
				<div id="$categoryCategories" class="categoryMode"></div>
				<div class="categoryMode categoryNav">
					<span class="textItem"><button id="$categoryPagesPrev" class="item">&lt;</button><button id="$categoryPagesNext" class="item">&gt;</button></span>
					<a class="textItem" id="$categoryCreatePage"><button class="item">Create Page</button></a>
				</div>
				<div id="$categoryPages" class="categoryPages categoryMode"></div>

				<div class="userActivity userMode" id="$userActivity"></div>

				<div class="pageInfoPane pageChatMode" id="$pageInfoPane">
					<!-- here we can put
						  tags, type, sb key info, etc.
					  -->
				</div>
				<div class="pageContents pre pageChatMode" id="$pageContents"></div>
				<div class="spacer pageChatMode"></div>

				<div id="$messageList" class="messageList pageChatMode"></div>
				
				<div class="editorPane editorMode">
					<div class="editorTextarea">
						<textarea id="$editorTextarea"></textarea>
					</div>
					<div class="editorPreview" id="$editorPreview"><div class="markup-root" ></div></div>
				</div>
				
				<div class="homeMode homePane paneGrow">
					hey<br>
					Users: <a href="#users">here</a><br>
					Pages: <a href="#categories/0">here</a><br>
					Activity: <a href="#activity">here</a><br>
					<hr>
					<blockquote>
						why is this so fast<br>
						what the fuck
						<footer>- snail_</footer>
					</blockquote>
				</div>
				<div class="membersMode memberPane">
					<div id="$memberList"></div>
				</div>

				<div class="registerMode">
					<form id="$registerForm">
						<input name="username" type="username" placeholder="Username" required minlength="3"><br>
						<input name="password" type="password" placeholder="Password" minlength="8" required><br>
						<input name="email" type="email" placeholder="Email" required><br>
						<button id="$register" onclick="event.preventDefault()">Register</button>
					</form>
					<button id="$resendEmail" onclick="event.preventDefault()">Resend Email</button>
					<div id="$registerError" class="pre"></div>
					<input id="$emailCode" placeholder="Confirmation Code"><br>
					<button id="$registerConfirm">Confirm</button>
				</div>

				<div class="settingsMode">
					<img id="$settingsAvatar" class="userPageAvatar avatar"><br>
					<input type="file" accept="image/*" id="$settingsAvatarUpload" autocomplete="off">
					<button id="$settingsAvatarSubmit">Submit</button><br>
					<a id="$userPageLink">Edit User Page</a>
				</div>

				<div class="activityMode" id="$activity">
				</div>
				
				<div class="bottomSpacer"></div>
			</main>
			
			
			<!--
				 Bottom of the page
			  -->
			<div class="inputPane chatMode">
				<textarea id="$chatTextarea"></textarea>
				<button id="$chatSend">Send</button>
			</div>
		</div>
		
		<div class="sideBar">
			<button id="$closeSidebar">Close Sibelius</button><br>
			<form class="textItem loggedOut" id="$loggedOut"><a href="#register">Register</a><br>
				<input id="$username" placeholder="username" name="username" class="item loginField"><input id="$password" type="password" name="password" placeholder="password" class="item loginField"><br>
				<button class="item" id="$login" onclick="event.preventDefault()">Log In</button></form>			
		</div>
	</div>
</body>
